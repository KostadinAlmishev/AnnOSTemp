\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}

\RequirePackage[left=30mm,right=20mm,top=20mm,bottom=20mm,headsep=0pt]{geometry}

\begin{document}

\paragraph{Приветствие (слайд 1).}
Здравствуйте, уважаемые члены комиссии. Доклад займет не более десяти минут.

\paragraph{Цели и задачи работы (слайд 2).}
Моя работа направлена на разработку учебной операционной системы, которая может
быть использована в курсе <<Проектирование операционных систем>>.

Для этого необходимо чтобы ядро ОС работало в 64-битном подрежиме длинного режима
и выполняло основные задачи операционных систем: управление памятью, управление
процессами, обработка прерываний и исключений, обработка системных вызовов.

Хотелось бы отметить, что на текущий момент нет учебных операционных систем,
разработанных под современную архитектуру AMD64, поэтому работа является актуальной.

\paragraph{Допущения и ограничения (слайд 3).}
На слайде 3 представлены ограничения и допущения, сделанные в работе: для ОС необходимо
не менее 32 мегабайт доступной физической памяти и не менее 40 мегабайт дискового пространства.

В разработанной ОС отсутствует поддержка файловой системы и многопроцессорной обработки.
Для упрощения реализации, код ядра выполняется с отключенными прерываниями.

Для запуска ОС необходимо использовать эмулятор QEMU.

\paragraph{Загрузка ОС (слайд 4).}
Для загрузки ОС необходимо выполнить следующие действия: активировать линию А20,
определить доступные области физической памяти, загрузить ядро, перейти в длинный
режим, подготовить требуемые ядру структуры данных, передать управление ядру.

Чтобы выполнить все эти действия, загрузчик должен быть написан полностью на языке
ассемблера, что приведет к усложнению кода и соответственно ухудшит его читаемость.

Поэтому в разработанной ОС используется двухэтапная загрузка. BIOS загружает с диска
первый сектор (512 байт), в котором находится первый загрузчик и передает ему управление.

Первый загрузчик активирует линию А20, определяет доступные физические области, используя
прерывания BIOS, переходит в защищенный режим, загружает и передает управление второму
загрузчику.

Второй загрузчик определяет доступный объем физической памяти, используя информацию, полученную
первым загрузчиком, подготавливает требуемые для работы ядра отображения и структуры данных:
GDT, PML4, массив дескрипторов страниц. Переходит в длинный режим, загружает и передает
управление ядру.

\paragraph{Действия для перехода в длинный режим (слайд 5).}
Для перехода в длинный режим второй загрузчик должен активировать PAE (установить бит PAE в регистре
CR4 в 1), создать дескрипторы сегментов кода для 64-битного режима, активировать длинный режим,
установив бит LME в моделезависимом регистре EFER в 1, загрузить адрес PML4 в регистр CR3 и
активироваться страничное преобразование, установив бит PG в регистре CR0 в 1.

\paragraph{Страничное преобразование (слайд 6).}
В длинном режиме механизм страничного преобразования использует четыре уровня таблиц страниц:
таблица страниц четвертого уровня (PML4), таблица указателей на каталоги страниц (PDP),
каталог страниц (PD) и таблица страниц (PT). Каждая таблица содержит 512 элементов, каждый из
которых имеет размер 8 байт, таким образом таблица страниц занимает одну страницу.

Механизм страничного преобразования и таблицы страниц используются чтобы обеспечить
каждый процесс областью физической памяти для хранения кода и данных, недоступной другим процессам.
Процесс не может получить доступ к физической памяти, которая не отображена в его адресное
пространство системным ПО.

\paragraph{Схема алгоритма создания отображения (слайд 7).}
Для работы механизма страничного преобразования необходимо создать отображения виртуальных адресов в
физические. На слайде 7 показана схема алгоритма создания отображения.

\paragraph{Схема алгоритма поиска элемента в таблице страниц (слайд 8).}
При создании отображения необходимо выполнять поиск элемента, указывающего на следующий элемент
в иерархии таблиц страниц. На слайде 8 показана схема алгоритма поиска элемента в таблице страниц.

\paragraph{Контекст процесса (слайд 9).}
Одной из основных задач ядра операционной системой является управление процессами.
Для реализации многозадачности с использованием одного ядра ЦП необходимо иметь возможность
приостанавливать и продолжать процессы. Для этого необходимо хранить контекст процесса
(значения регистров и адрес PML4). На данном слайде показан формат дескриптора процесса.
Структура контекста процесса была выбрана таким образом, чтобы она формировалась естественным
образом при возникновении прерываний.

\paragraph{Дескриптор процесса (слайд 10).}
Однако, для управления процессами одного контекста процесса недостаточно, поэтому каждый
процесс имеет дескриптор процесса, который включает: контекст процесса, имя и идентификатор процесса,
текущее состояние, виртуальный и физический адрес PML4. При работе с процессами ОС оперирует
именно дескрипторами процессов.

\paragraph{Состояние процессов (слайд 11).}
Помимо контекста и дескриптора, каждый процесс имеет состояние. В разработанной ОС процесс
может находиться в одном из четырех состояний: FREE, READY, RUN, DONT\_RUN. На слайде 11
показана диаграмма переходов состояний процессов.

\paragraph{Системные вызовы (слайд 12).}
Для работы прикладных программ, как правило, необходим доступ к различным сервисам ядра: вывод
на экран, выделение памяти, создание процессов. Однако, давать прикладным процессам прямой доступ
к данным возможностям не безопасно, т.к. в ошибка в прикладном процессе может привести к полной
неработоспособности всего ядра. Поэтому для обращения к системным сервисам ядро предоставляет
строго определенные точки входа: обработчики системных вызовов. Процесс передачи управление
такому обработчику называется системным вызовом.

В разработанной ОС реализованы 4 системных вызова: PUTS - выводит на экран строку, завершающуюся нулевым
символом. YIELD - вызывает планировщик, для передачи управления следующему процессу в очереди. EXIT -
уничтожает процесс, FORK - создает копию процесса.

\paragraph{Копирование при записи (слайд 13).}
В разработанной ОС для создания процессов используется системный вызов FORK. При выполнении системного
вызова создается новый процесс (процесс-потомок).

Процесс потомок полностью идентичен процессу-родителю, за исключением одного момента: системный вызов
возвращает 0 в процессе-потомке и идентификатор процесса (отличное от 0 значения) в процессе-родителе. Для
клонирования процессов используется механизм копирования при записи (англ. Copy On Write). Все доступные для записи
страницы помечаются как доступные только для чтения, т.е. для них сбрасывается бит <<W>> и устанавливается бит <<COW>>:
это один из неиспользуемых страничным преобразованием бит (11-й бит, если считать с 0), доступный для использования
системным ПО. Следует отметить, что после выполнения системного вызова содержимое таблиц PML4 дочернего и родительского
процессов совпадает.

При попытке записи одним из процессов в страницу доступную только для чтения произойдет страничное исключение.
Обработчик страничного исключения, для страниц у которых установлен бит COW, выделяет новую страницу из списка
свободных страниц и отображает ее в неиспользуемую область виртуального адресного пространства: \texttt{KERNEL\_TEMP},
добавляя права для записи (бит <<W>>). После этого копирует содержимое оригинальной страницы в эту область, удаляет
отображение для оригинальной страницы и отображает вместо него новую страницу. После чего, удаляет отображение для
\texttt{KERNEL\_TEMP}.

Данный процесс схематично показан на слайде 13.

\paragraph{Тестирование и отладка (слайд 14).}
Для тестирования ядра ОС написаны прикладные программы (функциональные тесты), которые позволяют
проверить функции вывода данных на экран; ограничения на чтение и запись данных в область ядра
и неотображенные области; функции создания и уничтожения процессов; и функции работы вытесняющей многозадачности.

Для отладки использовался стандартный для unix-подобных систем отладчик GDB.

\paragraph{Выводы (слайд 15).}
Итак, в результате выполнения дипломной работы, была разработана учебная операционная
система под современную архитектуру AMD64, обладающая следующими особенностями:
двухэтапная загрузка, страничное управление памятью, возможность исполнения прикладных
программ и запуска потоков ядра, поддержка вытесняющей многозадачности и поддержка
механизма копирования при записи.

Доклад окончен. Готов ответить на ваши вопросы.

\end{document}
