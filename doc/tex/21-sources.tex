\chapter{Огранизация исходных текстов Ann}
\label{cha:sources}

При разработке операционных систем традиционно используется язык Си по ряду
причин~\cite{mstu_os_dev_method}:
\begin{itemize}
\item возможность прямого доступа к памяти, манипуляции битовыми структурами,
	свободное приведение типов;
\item возможность собирать программы без подключения стандартной библиотеки;
\item совпадение имён в программе и в исходном файле (отсутствие
	декорирования имен, которое используется, например, компилятором языка
	C++);
\item отсутствие ненужных или трудно реализуемых в ядре сущностей, таких как
обработка исключений или сборка мусора;
\item возможность создания вставок на машинном языке;
\item относительная простота реализации компилятора языка.
\end{itemize}

Часть операционной системы не может быть реализована на языке С, поскольку
требует явного использования машинных команд, предназначенных для поддержки
реализации операционной системы. Такие части реализуются на языке ассемблера
-- в виде отдельных модулей или в виде ассемблерных вставок в функции на языке
С.

\section{Ассемблер GNU Assembler}
Исторически сложилось так, что существуют два альтернативных
синтаксиса ассемблера процессоров x86\_64: синтаксис Intel и синтаксис
AT\&T, известный как синтаксис UNIX. Первый из них был введен фирмой
Intel в своих руководствах для пояснительных примеров и был затем использован
авторами многих трансляторов, за заметным исключением GNU
Assembler (до версии 2.10 он не поддерживал синтаксис Intel). Второй основан
на том синтаксисе, который использовался в UNIX ещё до появления
самой платформы x86.

Хотя синтаксис Intel претендует на стандарт де-факто, Ann использует
синтаксис AT\&T как стандартный для средств разработки GNU и
большинства Unix-подобных систем. Основные отличия между двумя
синтаксисами перечислены ниже.

\paragraph{Порядок операндов.} В синтаксисе AT\&T присваивание идет
\textbf{слева направо (movl \$1, \%eax)}. В синтаксисе Intel -- \textbf{справа налево (mov eax, 1)}.

С одной стороны, пересылка в правом направлении совпадает с чте-
нием текста слева направо, с другой, \textbf{sub eax, 1} выглядит очевиднее,
чем \textbf{subl \$1, \%eax}, поскольку в последнем меняется порядок
вычитания, а в первом -- напрашивается аналогия с операцией <<-=>> в языке Си.

\paragraph{Суффиксы размерностей операндов.} В AT\&T команда заканчивается
однобуквенным суффиксом, показывающим разрядность операндов команды:
\begin{enumerate}[1)]
\item \textbf{b} -- byte, один байт;
\item \textbf{w} -- word, два байта;
\item \textbf{l} -- long, четыре байта;
\item \textbf{q} -- quad, восемь байт.
\end{enumerate}
Например: \textbf{movl somevar, \%eax}.

В синтаксисе Intel отсутствует четкий механизм задания размерности,
она определяется из разрядностей операндов: \textbf{mov eax, somevar}. В
случае, если операнд -- адрес памяти, в синтаксисе Intel используются префиксы
\textbf{byte ptr, word ptr, long ptr, quad ptr}, например: \textbf{mov eax, [long ptr 0x1000]}.

\paragraph{Префиксы операндов.} В AT\&T операнд дополняется особым
символом-префиксом (сиджилом), указывающим его вид:
\begin{itemize}
\item регистр -- процентом: \textbf{\%eax};
\item непосредственный операнд -- символом USD: \textbf{\$1};
\item косвенный (хранимый в памяти) адрес перехода -- звездочкой: \textbf{*addr}.
\end{itemize}

Прочие операнды в памяти не имеют сиджила, например: \textbf{0x1000} (это \textbf{не}
число 0x1000, а содержимое памяти по данному адресу!), \textbf{somevar}.

Благодаря префиксам синтаксисе AT\&T не возникает проблемы
различения обращения к переменной (т.е. по адресу памяти) и к адресу переменной
(т.е. использование его как непосредственного операнда). В синтаксисе
AT\&T \textbf{somevar} всегда означает ячейку памяти, а \textbf{\$somevar} -- адрес этой ячейки,
тогда как синтаксис Intel не устанавливает четких правил
на этот случай, что приводит к разногласиям в разных его реализациях.
Например, у транслятора NASM это будут, соответственно, \textbf{[somevar]} и
\textbf{somevar}, а у транслятора MASM — \textbf{somvar} и \textbf{OFFSET somevar}.

\paragraph{Адресация база-масштаб-смещение.}
В синтаксисе Intel сложение базы со смещением имеет интуитивный вид:
\textbf{[var + eax + 2*ebx]}. В синтаксисе AT\&T используется форма
\textbf{var(\%eax, 2, \%ebx)}. В случае, если какая-то из частей составного
адреса отсутствует, она пропускается: \textbf{-4(, \%eax, 2)} есть \textbf{[2*eax - 4]} в нотации Intel.

\section{Диалект GNU C}.
В Ann используется диалект языка C, известный как GNU C. Подчеркнём, что в дальнейшем
используется именно язык и компилятор Си, а не язык C++.

Поскольку при разработке ОС у нас не будет в распоряжении стандартной
библиотеки языка С (пока мы сами не создадим некоторую её
часть), то знания о ней нам почти не понадобятся.

Опишем две основные возможности диалекта GNU C.

\paragraph{Операция typeof.} Исходные тексты Ann предполагают наличие
конструкции \textbf{typeof}, крайне полезной для использования в макросах. Она
не введена в стандарт языка, поскольку, формально, её сложно назвать операцией:
её результат определяется во время компиляции (подобно операции sizeof) и
является типом аргумента, если он известен компилятору.

\paragraph{Составной оператор внутри выражения и inline-функции.} В
Ann встречаются многочисленные inline-функции, в основном.
Такие функции были введены в стандарте C99.

в диалекте GNU Си был добавлен составной оператор внутри выражения, причём возвращающий значение.
\begin{lstlisting}[language=C]
x = {int c = 2; c} + 1; // x == 3
\end{lstlisting}

\section{Ассемблерные вставки}
Если нам не нужно использовать много кода на ассемблере, а достаточно лишь пары строк
(например, записать значение переменной в порт ввода-вывода), имеет смысл
использовать ассемблерные вставки (англ. \textit{inline assembly}) -- механизм, позволяющий вставлять
ассемблерный код в тело функции на языке C. Для этого в компиляторе GCC существует ключевое
слово \textbf{asm}. Простейшая форма ассемблерной вставки имеет вид \textbf{asm ("....")}:
\begin{lstlisting}[language={[x86masm]Assembler}]
asm ("movl $0xfe, %eax \n"
     "outb %al, $0x64");
\end{lstlisting}

Содержимое строки внутри asm посылается на вход транслятору
gas (GNU Assembler), поэтому отдельные инструкции разделяются переносом строки (\\n).

В ассемблерной вставке нельзя напрямую обратиться к переменной
по её имени. Для этого существует полная форма:
\begin{lstlisting}[language={[x86masm]Assembler}]
asm(code
	: output variables
	: input variables
	: modified registers);
\end{lstlisting}

Полная форма вставки позволяет указать GCC, какие переменные
будут служить входными операндами для кода вставки, а какие -- выходными.
В коде вставки для обращения к операндам используется синтаксис
\%n , где n — порядковый номер операнда в общем списке.

Каждый операнд объявляется в списке при помощи синтаксиса
"constraint" (C expression) , где \textbf{constraint} определяет режим
адресации операнда. Существует довольно много форматов, из которых наиболее
часто используются "m" (входной операнд в памяти), "=m" (выходной операнд в
памяти), "r" и "=r" (входной-выходной операнд в любом регистре).

Например, следующий код скопирует значение переменной \textbf{x} в переменную \textbf{y}.
\begin{lstlisting}[language={[x86masm]Assembler}]
int x = 1, y;
asm ("movl %1, %eax \n" // movl x, eax
     "movl %eax, %0"    // movl eax, y
     : "=m" (y)
     : "m" (x));
\end{lstlisting}

В приведённом примере вместо \%1 подставляется адресное выражение для
переменной \textbf{x}, а вместо \%0 -- \textbf{y}.

Используя "r" , можно указать GCC, что необходимо выделить какой-нибудь
регистр общего назначения и сохранить туда значение указанного выражения
перед выполнением кода вставки. В следующем примере сумма переменных
\textbf{x} и \textbf{y} будет помещена в автоматически выбранный регистр общего назначения,
а потом скопирована в переменную \textbf{z} через регистр eax.

\begin{lstlisting}[language={[x86masm]Assembler}]
int x = 1, y = 2, z;
asm ("movl %1, %eax \n"
     "movl %eax, %0"
     : "=m" (z)
     : "r" (x + y));
\end{lstlisting}

Список модифицируемых регистров содержит все регистры, которые модифицируются
кодом вставки. Обычно его нет смысла указывать, так как GCC может сам определить,
какие регистры затрагиваются вставкой.

\section{Ограничение оптимизации обращений к переменным}
Допустим, имеется следующий код.
\begin{lstlisting}[language=C]
while (!ready);
\end{lstlisting}

Если переменная \textbf{ready} объявлена просто как \textbf{int ready}, реальное
обращение к хранящей значение переменной ячейке памяти, возможно,
произойдет лишь один раз, после чего последует бесконечный цикл. С
точки зрения компилятора значение \textbf{ready} не может измениться -- мы ведь не
изменяем значение её в теле цикла.

В языке C (стандарт C99) модификатор \textbf{volatile} означает, что
помеченная им переменная может изменить свое значение в любой момент.
Если переменную выше объявить как \textbf{volatile int ready}, компилятор будет
исходить из предположения, что некие другие сущности (например, другой поток
выполнения) может изменить значение переменной, и будет считывать её новое
значение из памяти после каждой итерации цикла.

Применительно к ассемблерным вставкам volatile имеет аналогичное значение:
он является сигналом компилятору, что приведённый блок ассемблерного кода
должен быть вставлен как есть, даже если, с точки зрения компилятора, его
выполнение не приведёт к наблюдаемым побочным эффектам. Дело в том, что GCC
пытается определить побочные эффекты ассемблерной вставки и, если они отсутствуют,
убрать её (в отличие от большинства компиляторов, которые просто отключают большую
часть оптимизаций для функции, где встречается хоть одна ассемблерная вставка).
Допустим, надо сделать задержку с помощью операции \textbf{nop} (отметим, что на практике
так делать нельзя, поскольку мы не знаем, сколько времени выполняется операция).
Для этого можно написать следующий код.
\begin{lstlisting}[language={[x86masm]Assembler}]
asm ("nop \n nop \n nop");
\end{lstlisting}

Компилятор GCC посчитает, что эти команды просто не нужны, так
же как он отбрасывает любые ненужные вычисления в коде на языке Cи.
Модификатор volatile укажет компилятору, что надо вставить ассемблерный код,
несмотря на отсутствие видимых побочных эффектов:
\begin{lstlisting}[language={[x86masm]Assembler}]
asm volatile ("nop \n nop \n nop");
\end{lstlisting}

Практически любые ассемблерные вставки, связанные не с оптимизацией вычислений
(использованием SSE и т. п.), а с взаимодействием с внешними устройствами или
другими потоками (lock xchg), требуют этого модификатора для правильной работы.

Следует отметить, что даже вставка с volatile может быть выкинута
из кода, если она недостижима.
\begin{lstlisting}[language={[x86masm]Assembler}]
if (0) {
	asm volatile("hlt"); // not reachable
}
\end{lstlisting}

\section{Обзор исходных текстов Ann}
Исходные тексты Ann размещены в каталоге \textbf{src}. Исходники Ann разделены
по следующим каталогам:
\begin{itemize}
\item \textbf{src/kernel} -- основные файлы ядра ОС;
\item \textbf{src/kernel/boot} -- файлы первого загрузчика ОС;
\item \textbf{src/kernel/loader} -- файлы второго загрузчика ОС;
\item \textbf{src/kernel/lib} -- служебная библиотека ядра (используется ядром
	и вторым загрузчиком);
\item \textbf{src/kernel/misc} -- вспомогательные заголовочные файлы;
\item \textbf{src/kernel/interrupt} -- файлы обработки прерываний;
\item \textbf{src/stdlib} -- стандартная библиотека (используется ядром и
	программами пользователя);
\item \textbf{src/user} -- файлы режима пользователя.
\end{itemize}

\section{Отладка кода ядра}
В ходе выполнения практических заданий вы наверняка столкнëтесь
с ситуацией, когда написанный вами код не работает или даже приводит к
аварийному завершению работы операционной системы. Поскольку в основном наш
код будет работать в режиме ядра, аварийное завершение его
работы будет довольно типичным результатом большинства ошибок.

К счастью, мы будем выполнять наш код на интерпретирующем эмуляторе,
что даст нам возможность легко просматривать содержимое ячеек
памяти и регистров ЦП, выводить содержимое стека, устанавливать точки
останова как по конкретным адресам, так и связывать их с событиями
изменения некоторых ячеек памяти и так далее.

\paragraph{Отладка с помощью GDB.} Для отладки ОС можно воспользоваться
стандартным отладчиком Unix-подобных систем -- GDB. Чтобы немного упростить
жизнь, автор написал несколько команд для этого отладчика, они находятся в
файле \textbf{src/.gdbinit}:
\begin{itemize}
\item \textbf{qemu} -- подключиться к эмулятору QEMU;
\item \textbf{debug-loader} -- подготовить окружение к отладке загрузчиков (первого и
	второго);
\item \textbf{debug-kernel} -- подготовить окружение к отладке ядра.
\end{itemize}

Как этим пользоваться (все действия нужно выполнять в директории \textbf{src}):
\begin{enumerate}[1.]
\item Собираем ядро (например: \textbf{make lab1});
\item Запускаем QEMU в режиме отладки (\textbf{make qemu-gdb});
\item В новой вкладке терминала запускаем GDB (\textbf{gdb});
\item Подключаемся к QEMU (\textbf{qemu});
\item Подготавливаем окружения для отладки загрузчика (\textbf{debug-loader});
\item Ставим точку останова (\textbf{break *0x7c00} или \textbf{break loader\_main});
\item Просим GDB выполнить инструкции до точки останова (\textbf{continue});
\item Можете приступать к отладке.
\end{enumerate}

\paragraph{Отладка ядра.} Для отладки ядра последовательность действий нужно
немного изменить, т.к. оно работает в длинном режиме, а загрузчики -- в
реальном и защищенном. GDB становится плохо при переходе из защищенного режима
в длинный, поэтому необходимо прибегнуть к небольшой уловке (это актуально
только для лабораторной №3 и далее), нужно сделать программную точку останова
в ядре (например в начале функции \textbf{kernel\_main()}):

\begin{lstlisting}[language=C]
bool debug = true;
while (debug == true) {
	// wait, until someone change condition above
}
\end{lstlisting}

После этого выполнить следующие шаги:
\begin{enumerate}[1.]
\item Собираем ядро (например: \textbf{make lab3});
\item Запускаем QEMU в режиме отладки (\textbf{make qemu-gdb});
\item В новой вкладке терминала запускаем GDB (\textbf{gdb});
\item Подключаемся к QEMU (\textbf{qemu});
\item Просим GDB начать выполнять инструкции (\textbf{continue});
\item Ждем несколько секунд и прерываем выполнение (\textbf{<CTRL> + C});
\item Подготавливаем окружения для отладки ядра (\textbf{debug-kernel});
\item Выходим из нашей программной точки останова: (\textbf{set variable debug = false});
\item Можете приступать к отладке.
\end{enumerate}

