\chapter{Начальная загрузка системы}
\label{cha:boot}

В этой работе мы соберем первую версию Ann, затем изучим процесс
начальной инициализации от включения компьютера до начала работы
ядра системы, используя эмулятор QEMU и отладчик GDB.

Платформа x86 была рассчитана на 16-битную ОС реального режима и
поэтому очень мало чем поможет загрузчику ядра операционной системы:
он не сможет даже использовать прерывания BIOS для чтения данных с диска.
В итоге весь процесс загрузки от начала работы загрузчика до
полной инициализации ядра чем-то напоминает <<вытаскивание себя самого
за волосы>>, причем итерационное: например, мы несколько раз сменим используемую таблицу GDT.

Эта особенность архитектуры x86 делает еë, возможно, даже более
привлекательной с учебной точки зрения: вместо необходимости изучения
объëмистой документации по взаимодействию со сложной системой
загрузки (например, современного стандарта UEFI) разработчик операционной
системы должен просто сделать сам всю эту работу, и нам придётся
принять в этом процессе самое непосредственное участие.

Перед началом работы нам следует создать на локальном диске репозиторий с
исходниками системы. Для этого запустим командную оболочку — все дальнейшие
команды мы будем выполнять в ней. Перейдем в каталог, выбранный как рабочий,
и затем выполним следующие команды для клонирования репозитория исходных
текстов Ann, использующего систему контроля версий Git.

\begin{lstlisting}[language=bash]
git clone https://github.com/spectrec/ann.git
cd ann
git checkout broken
\end{lstlisting}

Теперь у нас есть каталог \textbf{ann}, содержащий локальный
репозиторий исходных текстов Ann. Выполнив последнюю команду(\textbf{git checkout}),
мы переключились на ветку \textbf{broken} в этом репозитории. Команды \textbf{git branch} и
\textbf{git log} покажут нам текущую ветку и историю изменений
репозитория. Все дальнейшие команды системы git по работе с нашим репозиторием надо
выполнять, находясь в каталоге \textbf{ann} или любом его подкаталоге.

\section{Загрузчик ядра операционной системы}
Так уж сложилось что нас ОС -- 64-битная, а процесс перехода в длинный режим
не совсем тривиальный, это было одной из причин почему автор решил сделать
двухэтапную загрузку.

Исходные тексты первого загрузчика Ann находятся в файлах \textbf{src/kernel/boot/boot.S}
и \textbf{src/kernel/boot/main.c}. По соглашениям BIOS загрузчик будет загружен из первого
сектора устройства по адресу 0x7C00, а его размер не может превышать 512 байт.

Используемый в нашей системе загрузчик предполагает, что начиная со второго сектора
на диске находится второй загрузчик ОС -- в первом секторе диска находится сам загрузчик.
Для передачи управления второму загрузчику наш первый загрузчик должен
выполнить следующие шаги:
\begin{enumerate}
\item Сохранить карту областей физической памяти (memory map), чтобы ей мог воспользоваться второй загрузчик.
\item Переключить процессор в 32-битный защищённый режим и включить доступ к памяти свыше 1 Мб.
\item Считать заголовок второго загрузчика с диска в некоторую область памяти путём прямого программирования
контроллера IDE (наша система умеет работать только с IDE-дисками).
\item Извлечь из заголовка ELF-файла второго загрузчика информацию о его секциях и адрес точки входа.
\item Считать необходимые секции второго загрузчика с диска в ОЗУ.
\item Передать управление на адрес, рассчитанный на основе адреса точки входа из заголовка ELF-файла.
\end{enumerate}

\section{Формат файла ядра}
Собранное ядро находится будет находиться в файле \textbf{src/kernel/kernel} и
представлять собой файл в формате ELF -- стандартном формате исполняемых файлов во многих
unix-подобных системах. Поскольку в таких системах уже
есть компилятор и компоновщик для создания ELF-файлов, а сам формат
хорошо документирован, то автор Ann решил воспользоваться им.

Для просмотра информации о файле можно воспользоваться программой \textbf{readelf}.
Помимо секций и их адресов, интерес представляет также адрес точки входа в ядро,
показанный заголовке. Например, следующая команда покажет основную информацию
о содержимом файла ядра Ann.

\begin{lstlisting}[language=bash]
readelf -hS src/kernel/kernel
\end{lstlisting}

Найдите размеры и начальные адреса следующих основных секций файла:
\begin{itemize}
\item машинный код: секция \textbf{.text};
\item неинициализированные (т.е. нулевые) глобальные данные: секция \textbf{.bss};
\item инициализированные глобальные данные: секция \textbf{.data};
\item неизменяемые данные: секция \textbf{.rodata}.
\end{itemize}

Наш загрузчик ОС представляет собой упрощённый загрузчик ELF-файлов.
Бинарная структура таких файлов описана в заголовочном файле \textbf{kernel/misc/elf.h}.
Для компоновки второго загрузчика и ядра используется сценарий компоновщика:
\textbf{src/kernel/loader/linker.ld} и \textbf{src/kernel/linker.ld} соответственно.
В них, в частности, указаны базовые адреса компоновки.

\section{Сборка и запуск системы}
Для сборки исходников Ann в бинарный файл с образом диска нужно перейти
в каталог \textbf{ann/src} и выполнить команду \textbf{make}. После
успешной сборки образа системы командой \textbf{make} можно приступать к её
запуску в эмуляторе QEMU. Этот процесс уже был описан в главе~\ref{sec:debug}.
Но я продублирую его тут ещё раз, попробуем пошагово пройтись по инициализации
и рассмотреть некоторые моменты.

Если вы не знакомы с командами gdb, вот небольшая подборка (за более
подробной информацией обращайтесь к документации gdb):
\begin{itemize}
\item \textbf{n} выполнить текущую строку кода, не заходя в функцию (если на данной строке есть вызов функции);
\item \textbf{s} выполнить текущую строку кода, с заходом в функцию (если на данной строке есть вызов функции);
\item \textbf{si} выполнить текущую машинную инструкцию, с заходом в функцию (если текущая инструкция -- вызов функции);
\item \textbf{ni} выполнить текущую машинную инструкцию, с заходом в функцию (если текущая инструкция -- вызов функции);
\item \textbf{b <expr>} установить точку останова, \textbf{<expr>} может быть номером строки, адресом или функцией;
\item \textbf{c} продолжить выполнение до первой встреченной точки останова;
\item \textbf{info registers} показать содержимое регистров;
\item \textbf{p <expr>} вывести результат \textbf{<expr>}, например \textbf{p \$eax} покажет содержимое регистра \textbf{eax};
\end{itemize}

\paragraph{Собираем ядро.} Идем в директорию \textbf{ann/src}. Выполняем команду \textbf{make lab1};

\paragraph{Запускаем QEMU в режиме отладки.} Выполняем команду \textbf{make qemu-gdb};

\paragraph{Запускаем GDB.} Открываем новую вкладку терминала. Идем в директорию
\textbf{ann/src}. Выполняем команду \textbf{gdb};

\paragraph{Подключаемся к QEMU.} Выполняем команду \textbf{qemu};

\paragraph{Подготавливаем окружение для отладки загрузчика.} Выполняем команду \textbf{debug-loader};

\paragraph{Ставим точку останова.} Выполняем команду \textbf{break *0x7c00};

\paragraph{Просим GDB выполнить инструкции до точки останова.} Выполняем команду \textbf{continue};

\paragraph{Пошаговое исполнение.} Отлично, теперь можно немного подебажить. С
помощью команды \textbf{si} и \textbf{ni} можно пошагово пройтись по коду,
посмотреть как меняется содержимое регистров. Однако есть одна проблема: из-за
того, что загрузчик собран с опцией \textbf{-Os} (если верить интернетам),
команда \textbf{ni} работает так же как и \textbf{si}. Поэтому gdb будет
заходить во всех функции, в т.ч. и в прерывания.

Чтобы вас сильно не травмировать можно сразу поставить точку останова на
инструкцию, когда все прерывания уже были вызваны и продолжить пошаговое
выполнение оттуда, для этого выполняем следующие команды: \textbf{b memory\_detected} и \textbf{c}.

После инструкции \textbf{call bootmain} вы попадете в сишную часть первого
загрузчика, можете попробовать выполнить его пошагово, но поскольку он собран
с \textbf{-Os} поведение отладчика может вас немного удивить (вобще заниматься
отладкой оптимизированного кода через gdb -- дело неблагодарное).

В конечном счете вы сможете добраться до перехода во второй отладчик \textbf{((void (*)(void))(elf\_header->e\_entry))();}.
Зайдите внутрь это команды (команда \textbf{s}) и вы окажетесь в коде второго
отладчика, начиная с этого момента вы уже можете наслаждаться работой gdb,
т.к. тут он себя будет вести предсказуемо и все будет работать.

\section{Задание на лабораторную работу №1}
Пока что вам ним дописывать не нужно, поэтому лучше просто освойтесь в
исходниках, скриптах компоновщика и отладчике, а чтобы вам помочь, вот
несколько вопросов:

\begin{enumerate}
\item Посмотрите документацию к \textbf{BIOS INT 15h, AX=E820h}, расскажите,
	что за магия происходит внутри \textbf{detect\_high\_memory}?
\item Какой командой загрузчик переключает процессор в защищённый режим?
\item Как первый загрузчик инициализирует регистр указателя стека? Где находится стек при работе загрузчика?
\item Как устроена GDT загрузчика?
\item Начиная с какого физического адреса загружается первый загрузчик?
\item Начиная с какого физического адреса загружается второй загрузчик? А с какого виртуального?
\item Как загрузчик выделяет память для чтения второго загрузчика с диска?
\item Какая последняя исполняемая команда первого загрузчика (особо любознательным может помочь \textbf{layout asm})?
\item Какая первая исполняемая команда второго загрузчика?
\end{enumerate}
