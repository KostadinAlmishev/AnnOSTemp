\chapter{Конструкторский раздел}
\label{cha:design}

Для того чтобы получить доступ ко всем возможностям архитектуры AMD64
необходимо использовать 64-битную ОС, для работы которой необходимо перейти в 64-битный
подрежим длинного режима.

Так как одним из основных требований к разрабатываемой операционной системе
является простота, было решено использовать монолитное ядро, т.к. в этом
случае ядро будет представлять собой одну программу (все сервисы находятся в
одном адресном пространстве). Для упрощения кода ядра, было решено
не добавлять поддержку нескольких процессоров.

Для запуска операционной системы необходимо настроить минимальное окружение~\cite{mstu_os_dev_method} (активировать линию A20,
загрузить GDT, перейти в защищенный режим), загрузить ОС в память и передать ей управление.
Этим занимается загрузчик операционной системы (англ. bootloader). Существует множество загрузчиков
(GRUB, Lilo, Gujin, Bootf и др.), однако они не лучшим образом подходят для учебных целей, т.к. поддерживают
различное оборудование и файловые системы (что приводит к увеличению объемов и усложнению исходного кода),
поэтому было принято решение реализовать собственный загрузчик.

Таким образом необходимо разработать многозадачную однопроцессорную операционную систему с
монолитным ядром под архитектуру AMD64. Операционная система должна
иметь собственный загрузчик и использовать 64-битный подрежим длинного режима. Необходимо
реализовать поддержку страничного преобразования (т.к. без него невозможно перейти в длинный режим).
Для взаимодействия прикладных процессов с ядром необходимо реализовать механизм системных вызовов.


\section{Расположение ядра в памяти}
Как было сказано в главе~\ref{sec:page_translation}, в 64-битном режиме может использоваться
до 48 бит виртуального адреса (9 + 9 + 9 + 9 + 12), таким образом доступное адресное пространство
составляет 256~терабайт.

Как правило, ядро отображется в виртуальное адресное пространство каждого процесса (но при этом код ядра
остается доступным только на нулевом уровне привилегий), что позволяет снизить накладные расходы при
обращении к сервисам ядра.

Существует 2 основных способа расположения ядра в виртуальной памяти: в верхней части (англ. Higher Half Kernel)
и в нижней. Основными преимуществами расположения ядра в верхней части виртуального адресного пространства являются:
\begin{itemize}
\item Независимость приложений от размеров адресного пространства ядра (в случае расположения ядра в нижней части
	адресного пространства, при изменении размеров ядра может потребоваться перекомпиляция существующих
	прикладных программ).
\item 32-битные процессы могут использовать все 4~гигабайта адресного пространства.
\end{itemize}

Поэтому было решено разместить ядро в верхней части виртуального адресного пространства. Область, занимаемая
ядром в виртуальной памяти, будет расположена начиная с адреса 0xFFFF\,FFF8\,0000\,0000, т.к. это
позволит иметь прямой доступ к первым 32 гигабайтам физической памяти. Этого должно быть достаточно для
учебной операционной системы. Далее в тексте для обозначения базового адреса ядра будет использоваться
обозначение \textbf{KERNEL\_BASE}.

Ниже \texttt{KERNEL\_BASE} расположены стек, отображения и структуры данных необходимые для
работы ядра.

Процессам уровня пользователя выделен 1~терабайт (0x0000\,0100\,0000\,0000) виртуального пространства.
Далее в тексте для обозначения верхнего лимита пространства пользователя будет использоваться
обозначение \textbf{USER\_TOP}.

На рис.~\ref{fig:vm-layout} показана схема организации виртуальной памяти ОС.
\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.7\textwidth]{inc/dia/vm-layout}
  \caption{Организация памяти ОС}
  \label{fig:vm-layout}
\end{figure}

\section{Расположение ядра на диске}
BIOS считывает первый сектор диска в память по адресу 0x7C00 и передает на него управление.
Для упрощения кода загрузчика было решено не добавлять поддержку файловой системы, а
использовать следующие соглашения: в первом секторе диска располагается первый
загрузчик, начиная со второго сектора располагается второй загрузчик, ядро начинается
с 2048-го сектора (1~мегабайт). На второй загрузчик отведен почти
1 мегабайт диского пространства, чтобы его можно было расширять, без необходимости перемещать
ядро. На рис.~\ref{fig:disk-usage} привидена схема использования диского пространства.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/disk-usage}
  \caption{Использование диского пространства}
  \label{fig:disk-usage}
\end{figure}


\section{Загрузка ОС}

\subsection{Начальная загрузка компьютера}
Ядро будет расположено в верхней части
виртуального адресного пространства, поэтому для передачи управления коду
ядра необходимо перейти в длинный режим (т.к. в унаследованном режиме доступно
только 4~гигабайта адресного пространства). Таким образом загрузчик должен
выполнить следующие действия~\cite{mstu_os_dev_method}:
\begin{enumerate}[1.]
\item Открыть вентиль линии А20;
\item Определить доступные области физической памяти;
\item Загрузить ядро в физическую память;
\item Перейти в длинный режим;
\item Передать управление ядру;
\end{enumerate}

Для выполнения всех перечисленных действий первым загрзучиком, необходимо реализовать
его полностью на языке ассемблера, что приведет к сложному и нечитаемому коду, который
плохо подходит для учебного процесса.

Поэтому было принято решение использовать 2 загрузчика, что позволит частично реализовать
их на языке Си (и соответственно улучшит читаемость кода).

\subsubsection*{Первый загрузчик}
Первый загрузчик выполняет следующие действия: открытие вентиля линии А20, определение доступных
областей физической памяти, переход в защищенный режим, загрузка и передача управления
втором загрузчику.

\paragraph{Линия А20.} Для открытия вентиля линии А20 используется контроллер клавиатуры 8042.

\paragraph{Доступные области физической памяти.} На некоторые области физической памяти
отображены регистры аппаратного обеспечения, поэтому их нельзя использовать для размещения
данных пользователя и операционной системы. Информацией обо всех областях физической памяти
обладает BIOS. Для ее получения можно воспользоваться прерываниями BIOS, в частности -- INT 0x15.

Для определения карты распределения памяти будет использована функция 0xE820 0x15-го прерывания
BIOS. Данная функция возвращает карту всей доступной памяти и физические области, зарезервированные
BIOS~\cite{bios_int15h}. Функцию необходимо вызывать в цикле, после каждого вызова функция возвращает
информацию об очередной области физической памяти, содержащую базовый адрес, длинну и тип области
(свободна или занята) и атрибуты. На рис.~\ref{fig:bios-int-0x15} показан формат возвращаемых данных.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.9\textwidth]{inc/dia/bios-int-0x15}
  \caption{Формат структуры области памяти}
  \label{fig:bios-int-0x15}
\end{figure}

Для использования этой функции необходимо в EAX занести значение 0xE820, в EDX -- 0x534d4150 (SMAP),
в ES:DI занести адрес, по которому необходимо сохранить дескриптор области памяти. Загрузчик
заносит в ES:DI адрес 0000:7E00, т.к. сам загрузчик расположен по адресу 0000:7C00 и
занимается 512 байт (0x7C00 + 512 = 0x7E00). EBX должен содержать 0.

После каждого вызова функция изменяет значение EBX, чтобы очередной вызов вернул информацию о следующей
области. При успешном выполнении RFLAGS.CF сброшен в 0, EAX содержит значение 0x534d4150 (SMAP).
Функция не увеличивает значение ES:DI, поэтому после каждого вызова его нужно увеличивать на 24 (размер
дескриптора области памяти).

Прерывания BIOS недоступны в защищенном режиме, поэтому эту информацию может получить только первый загрузчик.

\paragraph{Переход в защищенный режим.} Для перехода в защищенный режим необходимо создать GDT,
содержащую как минимум 3 сегмента: нулевой сегмент, сегмент кода и сегмент данных. Данные сегменты
должны занимать все доступное адресное пространство (4~Гб), для этого необходимо чтобы поле
<<базовый адрес>> было равно 0, поле <<лимит>> было равно 0xFFFFF и были установлены биты
<<P>>, <<S>>, <<G>>, <<D>>, сегмент данных должен быть доступен для записи (бит <<W>>).

После создания GDT, нужно обновить регистр GDTR, для этого можно воспользоваться командой LGDT.
При таком отображении виртуальные адреса совпадают с физическими.

Далее необходимо установить бит CR0.PE в 1. После этого процессор окажется в защищенном режиме,
однако сегментные регистры все ещё содержат дескрипторы сегментов реального режима, поэтому необходимо
обновить значения сегментных регистров, чтобы они содержали дескрипторы сегментов защищенного
режима. Для обновления селекторов сегментов данных используется команда MOV. Чтобы обновить селектор
сегмента кода необходимо использовать команду LJMP.

\paragraph{Загрузка и передача управления второму загрузчику.} Чтение загрузчика с диска
осуществляется напрямую через порты ввода/вывода контроллера IDE. Второй загрузчик
расположен в фиксированной области диска (начиная с первого сектора, если считать с 0), это
позволяет прочитать его заголовок (в формате ELF~\cite{elf}), который содержит информацию о
секциях и адрес точки входа.

Первый загрузчик загружает второй загрузчик в физические адреса, указанные в файле
(начиная с 1-го мегабайта физической памяти, если считать с 0). И передает управление
второму загрузчику (адрес точки входа содержится в заголовке).


\subsubsection*{Второй загрузчик}
Второй загрузчик подготавливает все необходимые ядру структуры данных, загружает ядро,
переходит в длинный режим и передает управление ядру.

\paragraph{Определение доступной памяти.} С помощью списка доступных участков физической
памяти, полученного первым загрузчиком необходимо определить максимальное значение адреса,
это и будет значением доступной физической памяти. Это значение в последствии используется
для определения количества доступных физических страниц. Для обозначения объема доступной
физической в памяти далее в тексте будет использоваться обозначение \textbf{PHYS\_MEM}.

\paragraph{Загрузка ядра.} Как было сказано ранее, ядро ОС, так же как и второй загрузчик,
расположено в фиксированной области диска (начиная с 2048 сектора). Ядро, так же как и загрузчик
имеет формат ELF и будет загружено начиная со второго (если считать с 0) мегабайта физической
памяти. В программных заголовках виртуальные адреса ядра находятся после \texttt{KERNEL\_BASE} (код
ядра начинается с адреса \texttt{KERNEL\_BASE} + 2~мегабайта), поэтому при загрузке необходимо
сбрасывать старшие 32~бита 64-битных виртуальных адресов. Это необходимо чтобы виртуальные адреса
ядра стали корректными после создания специального отображения.

\paragraph{Подготовка стрктур данных.} После загрузки ядра, необходимо выделить память и проинициализировать
используемые структуры данных: GDT, PML4, массив дескрипторов страниц и структуру, для передачи
ядру всей необходимой информации (на рис.~\ref{fig:kernel-info-structure} показан ее формат), включающую:
адрес GDT, PML4 массив дескрипторов страниц и их количество). Далее в текте для ссылки на эту структуру
данных будет использоваться обозначение \textbf{KERNEL\_INFO}. Ядро само не может получить эту информацию,
т.к. она зависит от объема физической памяти, занимаемой загрузчиком.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.7\textwidth]{inc/dia/kernel-info-structure}
  \caption{Формат структуры данных для передачи ядру}
  \label{fig:kernel-info-structure}
\end{figure}

Для сохранения необходимых ядру структур данных нельзя использовать заранее определенные адреса,
т.к. неизвестен размер загрузчика, поэтому память под них нужно выделять во время выполнения. Для
этого необходимо определить конечный адрес загрузчика и использовать память, расположенную за ним.

При инициализации GDT нужно выделить память минимум под 6 дескрипторов сегментов:
\begin{enumerate}[1.]
\item нулевой;
\item сегмент кода ядра;
\item сегмент данных ядра;
\item сегмент кода прикладных программ;
\item сегмент данных прикладных программ;
\item TSS.
\end{enumerate}

Дескрипторы сегментов кода должны содержать бит <<L>>, чтобы процессор переходил в длинный
режим при их загрузке.

Для упрощения отображения структур данных, память будет выделяться блоками размером 4~килобайта (одна страница),
выровненным также по границе 4~килобайта. Таким образом загрузчик выделяет одну страницу для GDT, необходимое
количество страниц для массива дескрипторов страниц (формат дескриптора страницы показан на рис.~\ref{fig:page-descriptor}),
одну страницу для PLM4 и одну страницу для \texttt{KERNEL\_INFO}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.7\textwidth]{inc/dia/page-descriptor}
  \caption{Формат дескриптора страницы}
  \label{fig:page-descriptor}
\end{figure}

Далее в тексте для обозначения первого свободного адреса, находящегося за загрузчиком будет использоваться
обозначение \textbf{LOADER\_END}.


\paragraph{Инициализация свободных страниц.} После того, как выделена память под все
необходимые структуры данных, необходимо проинициализировать список свободных страниц,
с учетом списка доступных участков, полученного превым загрузчиком и областей,
занятых ядром и вторым загрузчиком.

\paragraph{Отображения.} Как было сказано ранее, в длинном режиме механизм страничного преобразования
использует 4 уровня таблиц страниц: PML4, PDP, PD и PT. Для создания отображения виртуального адреса
в физический необходимо заполнить эту иерархию. На рис.~\ref{fig:page-translation-schema} показана схема
алгоритма создания отображения виртуальной страницы в физическую.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.7\textwidth]{inc/dia/page-translation-schema}
  \caption{Схема алгоритма создания отображения страницы}
  \label{fig:page-translation-schema}
\end{figure}

Алгоритм поиска элемента в таблице страниц приведен на рис.~\ref{fig:page-table-entry-search}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/page-table-entry-search}
  \caption{Схема алгоритма поиска элемента в таблице страниц}
  \label{fig:page-table-entry-search}
\end{figure}

Следует заметить, что в таблицах страниц хранятся физические адреса. В загрузчике виртуальные
адреса совпадают с физическими, поэтому загрузчик работает с таблицами страниц, как с массивами,
каждый из которых содержит 512 элементов, имеющих размер 64~бита.

Однако в ядре виртуальные и физические адреса отличаются, поэтому для возможности управления
таблицами страничного преобразования в ядре необходимо иметь возможность программно преобразовывать
физический адрес в виртуальный и наоборот. Для обеспечения такой возможности было решено
создать отображение виртуальной области \texttt{[KERNEL\_BASE, KERNEL\_BASE+PHYS\_MEM)}
в физическую \texttt{[0, PHYS\_MEM)}.

Благодаря этому отображению ядро получает возможность напрямую работать с таблицами страниц,
для этого необходимо к адресу, содержащемся в элементе таблицы страниц прибавить \texttt{KERNEL\_BASE},
в результате будет получен виртуальный адрес таблицы страниц, к элементам которой можно обращаться из
ядра. Аналогично, для того чтобы получить физический адрес таблицы страниц, необходимо из виртуального
адреса вычесть \texttt{KERNEL\_BASE}.

Кроме того, данное отображение имеет ещё одно важное свойство, оно необходимо для корректного
преобразования виртуальных адресов ядра в физические (в которые загружено ядро, благодарю обнулению
старших 32 бит адреса при загрузке).

Так как в загрузчике виртуальные адреса совпадают с физическими, необходимо создать отображение,
преобразующее виртуальные адреса загрузчика в такие же физические. Для этого загрузчик создает
отображение виртуальной области \texttt{[0, LOADER\_LEN)} в физическую \texttt{[0, LOADER\_LEN)}. Это необходимо,
чтобы иметь возможность выполнять инструкции загрузчика после активации страничного преобразования.

Перед переходом в длинный режим и передачей управления ядру ОС, необходимо добавить в иерархию таблиц
страниц отображения для стека ядра, регистров APIC и IOAPIC, структуры \texttt{KERNEL\_INFO}.
Для отображения этих областей будут использованы адреса младше \texttt{KERNEL\_BASE} (т.к. адреса,
начиная с \texttt{KERNEL\_BASE} и старше -- заняты ядром).


\paragraph{Переход в длинный режим.} После отображения всех необходимых ядру данных,
загрузчик выполняет переход в длинный режим. Для этого он выполняет следующие действия:
\begin{enumerate}[1.]
\item Загружает в GDTR новую GDT. Это действие не влияет на выполнение дальнейших инструкций,
	т.к. теневые части сегментых регистров содержат дескрипторы из предыдущей GDT, чтобы
	изменения вступили в силу, необходимо загрузить новые значения в сегментные регистры.
\item Активирует PAE (CR4.PAE=1). Это действие не влияет на выполнение дальнейших инструкций,
	т.к. страничное преобразование в данный момент отключено.
\item Загружает в регистр CR3 адрес PML4. Это действите, как и предыдущее не влияет на
	выполнение дальнейших инструкций, т.к. страничное преобразование в данный момент
	отключено.
\item Активирует длинный режим (EFER.LME=1). Это действие не влияет на выполнение дальнейших
	инструкций, но оно необходимо чтобы процессор перешел в длинный режим при включении
	страничного преобразования.
\item Активирует страничное преобразование (CR0.PG=1). После активации страничного преобразования
	для получения физического адреса процессор будет использовать иерархию таблиц страниц,
	таким образом для возможности продолжения работы загрузчика, после активации страничного
	преобразования необходимо чтобы виртуальные адреса загрузчика совпадали с физическими (как
	было при использовании только сегментного преобразования), это требование выполняется
	благодаря наличию отображения виртуальной области \texttt{[0, LOADER\_END)} в физическую область
	\texttt{[0, LOADER\_END)}.
\end{enumerate}

С этого момента процессор находится в подрежиме совместимости длинного режима.
Для перехода в 64-битный режим, необходимо обновить содержимое регистра CS (загрузить в
него дескриптор 64-битного сегмента кода). После этого загрузчик передает управление ядру.

\section{Ядро ОС}

\subsection{Инициализация структур данных}
Для работы ядра необходимы структуры данных, подготовленные вторым загрзучиком:
адрес GDT, PML4 и массив дескрипторов страниц. Загрузчик создал отображение в
виртуальном адресном пространстве ядра для доступа в этим структурам (\texttt{KERNEL\_INFO}).

Содержащиеся в структуре \texttt{KERNEL\_INFO} адреса находятся в виртуальном адресном
пространстве загрузчика и совпадают с физическими (за счет использования загрузчиком плоской
модели памяти).

Для их преобразования в корректные адреса в виртуальном адресном пространстве ядра
достаточно прибавить к ним значение \texttt{KERNEL\_BASE} (благодаря наличию отображения,
выполненного загрузчиком).

Для возможности продолжения исполнения кода загрузчика после активации страничного преобразования
было создано отображение виртуальной области \texttt{[0, LOADER\_END)} в физическую \texttt{[0, LOADER\_END)},
после передачи управления ядру данное отображение больше не нужно и его можно удалить. Однако, перед
удалением отображения необходимо обновить GDTR, т.к. он содержит виртуальный адрес GDT в адресном
пространстве загрузчика (совпадает с физическим адресом).

\subsection{Управление процессами}
Одной из основных задач ядра операционной системой является управление процессами. В данной
главе описаны используемые для этого механизмы и структуры данных.

Для реализации многозадачности с использованием одного ядра ЦП необходимо иметь возможность
приостанавливать и продолжать процессы. Для этого необходимо хранить контекст процесса
(значения регистров и адрес PML4). Структура контекста процесса была выбрана таким образом,
чтобы она формировалась естественным образом при возникновении прерываний. Формат структуры
контекста процесса показан на рис.~\ref{fig:process-context}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth]{inc/dia/process-context}
  \caption{Контекст процесса}
  \label{fig:process-context}
\end{figure}

Однако, для управления процессами одного контекста процесса недостаточно, поэтому каждый
процесс имеет дескриптор процесса, который включает: контекст процесса, имя и идентификатор процесса,
текущее состояние, виртуальный и физический адрес PML4. Формат дескриптора процесса показан
на рис.~\ref{fig:process-descriptor}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.4\textwidth]{inc/dia/process-descriptor}
  \caption{Дескриптор процесса}
  \label{fig:process-descriptor}
\end{figure}

Согласно~\cite{tanenbaum}, процесс может находиться в трех состояниях:
\begin{itemize}
\item \texttt{выполняемый} -- в данный момент используется центральный процессор;
\item \texttt{готовый} -- работоспособный, но временно приостановленный, чтобы дать
	возможность выполняться другому процессу;
\item \texttt{заблокированный} -- неспособный выполняться, пока не возникнет какое-либо
	внешнее событие.
\end{itemize}

В разрабатываемой ОС состоянию \texttt{выполняемый} соответствует состояние \texttt{RUN},
состоянию \texttt{готовый} -- \texttt{READY}, состоянию \texttt{заблокированный} -- \texttt{DONT\_RUN}.

Также было введено дополнительное состояние \texttt{FREE}, которое означает что дескриптор свободен и
может быть использован для создания нового процесса.

На рис.~\ref{fig:process-state-diagramm} представлена диаграмма состояний процесса.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth]{inc/dia/process-state-diagramm}
  \caption{Диаграмма состояний процесса}
  \label{fig:process-state-diagramm}
\end{figure}

\paragraph{Хранение дескрипторов процессов.}
Существует два способа выделения памяти под дескрипторы процессов: статический и динамический.
Основным преимуществом динамического выделения является возможность выделять память по требованию
и освобождать память из-под неиспользуемых ресурсов. Основным недостатком является то, что
для реализации динамического выделения памяти в пространстве ядра необходимо реалиализовывать
аллокаторы памяти, что приводит к увеличению объема исходного кода и как следствие -- его сложности.

Основным преимуществом статического выделения памяти является то, что этот способ позволяет
выделить память под все критичные структуры данных ядра на этапе загрузки ядра, это означает,
что страничное преобразование общей для всех процессов области ядра не меняется в ходе работы
ОС, что избавляет от необходимости его синхронизации. Основным недостатком является ограничение
числа возможных процессов и накладные расходы, связанные с расходом памяти на неиспользуемые
дескрипторы процессов. Однако данные недостатки являются несущественными для учебной операционной
системы, поэтому было принято решение выделить память статически (дескрипторы процессов хранятся
в глобальном массиве).

Для упрощения поиска свободного дескриптора процесса, все дескрипторы организованы в связный список.
При создании нового процесса, дескриптор удаляется из этого списка. При уничтожении процесса --
дескриптор добавляется обратно в этот список.

\paragraph{Планирование процессов.}
Современные ОС для упрощения работы планировщика создают холостой (англ. idle) процесс,
который используется для сбора различной статистики о системе. В разрабатываемой ОС такой
процесс будет реализован с использованием потоков ядра. Его единственной задачей будет вызов
планировщика для передачи управления другим процессам, таким образом в системе всегда будет
как минимум один рабочий процесс, который можно запустить.

Разрабатываемая ОС не поддерживает приоритеты процессов, планирование осуществляется
по алгоритму Round Robin~\cite{tanenbaum}.

Вытеснение процессов происходит при возникновении прерывания по таймеру или посредством
системного вызова.

\paragraph{Прикладные программы.}
Операционная система выделяет каждому процессу отдельное адресное пространство, изолированное
от других процессов, защищая таким образом процессы друг от друга. В этом случае один процесс
не может разрушить структуры данных другого процесса.

Для создания отдельного адресного пространства операционная система выделяет каждому процессу
отдельную PML4, в которую копируется область, отвечающая за страничное преобразование адресов
ядра, таким образом доступ к области ядра можно получить из адресного пространства любого процесса,
находясь на нулевом уровне привилегий. Данный метод позволяет избежать накладных расходов, при
обращении к сервисам ядра.

Прикладные программы, так же как и ядро, имеют формат ELF. Так как ОС не поддерживает файловую
систему, данные программы являются частью ядра. При создании процесса, после начальной
инициализации PML4, ядро выделяет память под стек процесса (используя доступные страницы)
и добавляет в PML4 отображение для стека (также, как это делал загрузчик при загрузке ядра).
После этого ядро переходит в адресное пространство процесса (загружая в CR3 адрес новой PML4) и
загружает код и данные процесса согласно информации, содержащейся в программных заголовках.

Следует обратить внимание, что код ОС продолжает корректно выполняться после загрузки новой PML4,
т.к. область отвечающая за адреса ядра остается неизменной.

После создания всех необходимых отображений, ядро инициализирует контекст процесса: указывает
физический и виртуальный адреса PML4, виртуальный адрес вершины стека и виртуальный адрес
точки входа, задает селекторы сегментов кода и данных, после чего меняет статус нового процесса
на \texttt{READY}, чтобы планировщик запустил процесс, когда до него дойдет очередь.

Для запуска процесса планировщик восстановит его состояние из контекста: восстановит
значения регистров общего назначения, загрузит в CR3 адрес PML4 данного процесса, загрузит
в сегментные регистры селекторы сегментов данных, после чего, с помощью команды IRET восстановит
стек и селектор сегмента кода, тем самым выполнив переход в пространство пользователя.

\paragraph{Потоки ядра.} Большинство ядер современных операционных систем (Linux, BSD и др.),
помимо процессов, имеют ещё один примитив диспетчеризации: потоки ядра, которые представляют
собой процессы, выполняющиеся в пространстве ядра. Как правило, потоки ядра используются для
выполнения различных служебных функций ядра, например: завершение обработки прерываний (обработчик
прерывания сохраняет в очереди информацию о прерывании и завершается, а поток ядра выполняет все
необходимые действия по обработке прерывания). В разрабатываемой ОС используется один поток ядра в качестве
холостого процесса, который всегда передает управление другим процессам (вызывает
процедуру планирования).


\subsection{Прерывания}
Для обработки прерываний и исключений используется IDT. Ядру необходимо создать обработчики
прерываний и исключений, и загрузить IDT, содержащую ссылки на эти обработчики.

Ядру ОС необходимо инициализировать TSS (установить указатель стека для нулевого уровня привилегий,
и добавить указатели стеков в массив IST для прерываний и исключений), выделить память под стеки
обработчиков прерываний и исключений. После чего загрузить в регистр TR дескриптор TSS.

Для описания обработчиков прерываний и исключений используются шлюзы дескрипторов прерываний.
Это позволяет упростить обработчики прерываний и исключений, т.к. при этом они могут быть
нереентерабельными и использовать глобальные переменные.

Обработчики аппаратных прерываний используют механизм IST для переключения стека, для этого
в дескрипторе шлюза прерывания в поле IST заносится индекс IST в TSS. Это позволяет
разрешить прерывания в потоках ядра, используя небольшой (1 страница) стек. В противном случае
обработка прерывания может вызвать переполнение стека потока ядра, т.к. потоки ядра выполняются
на нулевом уровене привилегий, то при возникновении прерывания переключение стека не произойдет
(при использовании унаследованного механизма переключения стека), поэтому обработка прерывания
будет выполняться с использованием стека потока ядра.

Перед разрешением прерываний необходимо инициализировать APIC и настроить IOAPIC. Для этого
необходимо установить бит <<AE>> в регистре базового адреса APIC (глава~\ref{sec:apic_ioapic}).

\paragraph{Настройка IOAPIC.} Перед настройкой IOAPIC ОС должна отключить PIC (замаскировать его прерывания),
чтобы избежать конфликтов~\cite{os_dev}. ОС сохраняет в регистрах IOREDTBL информацию о перенаправлении
прерываний: прерываний от таймера (с номером 0), будут доставляться в локальный APIC с номером 32, а прерывания от
клавиатуры (с номером 1) -- с номером 33. Это необходимо чтобы иметь возможность отличать стандартные исключения и
прерывания от прерываний от аппаратного обеспечения, которые используют те же номера.

\paragraph{Настройка таймера.} Для инициализации таймера необходимо в регистр ICR занести начальное значение
таймера, в регистр DCR -- значение, на которое будет уменьшаться значение CCR при каждом тике таймера,
а в регистр Timer LVT занести номер вектора прерывания и установить бит <<TM>>, чтобы таймер повторно
инициализировался после срабатывания.

\paragraph{Обработка прерываний и исключений.} Обработчик прерывания должен сохранить контекст прерванного
процесса, для возможности последующего корректного продолжения работы последнего после завершения обработки
прерывания.

Возврат из прерывания происходит так же, как и запуск процесса (с использованием контекста процесса,
сохраненного обработчиком прерывания).


\subsection{Системные вызовы}
Для работы прикладных программ, как правило, необходим доступ к различным сервисам ядра: вывод
на экран, выделение памяти, создание процессов. Однако, давать прикладным процессам прямой доступ
к данным возможностям не безопасно, т.к. в ошибка в прикладном процессе может привести к полной
неработоспособности всего ядра. Поэтому для обращения к системным сервисам ядро предоставляет
строго определенные точки входа: обработчики системных вызовов. Процесс передачи управление
такому обработчику называется системным вызовом. В длинном режиме существует два способа
выполнения системного вызова:
\begin{enumerate}[1.]
\item Используя инструкцию INT. В качестве параметра данной инструкции передается номер прерывания;
\item Используя инструкции SYSCALL и SYSRET.
\end{enumerate}

Для использования инструкций SYSCALL и SYSRET необходимо инициализировать управляющие регистры
процессора и создавать GDT в строго определенном формате, поэтому было принято решениe для
выполнения системных вызовов использовать инструкцию INT. В разрабатываемой ОС, системный вызов
имеет номер 34.

Некоторые системные вызовы принимают аргументы, сущесвует два основных способа передачи
аргументов в системный вызов: используя регистры или стек. В учебной ОС системные вызовы,
как правило, не принимают аргументов, либо принимают 1-2 аргумента. Поэтому было принято
решение для передачи аргументов использовать регистры: RAX, RBX, RCX, RDX, RSI, RDI.
Причем через RAX передается номер системного вызова, а аргументы -- через оставшиеся 5 регистров.

В случае, если потребуется передать больше 5 аргументов, прикладной процесс должен выделить
на стеке структуру, содержащую требуемые аргументы и передать ее адрес через один из регистров,
обработчик системного вызова сможет обращаться к элементам структуры, т.к. он выполняется в адресном
пространстве процесса и имеет доступ к его стеку.

\paragraph{Выполнение системных вызовов.}
Для выполнения системного вызова прикладные процессы используют библиотеку, которая
скрывает детали реализации системных вызовов. С точки зрения прикладных программ системный
вызов выглядит как вызов подпрограммы. Библиотечные функции сохраняют переданные аргументы и
номер требуемого системного вызова в регистры, после чего выполняют команду \texttt{INT 34}.
Для возврата значения из системного вызова используется регистр RAX, его содержимое после
выполнения системного вызова возвращается библиотечной функцией прикладному процессу.

\paragraph{PUTS.} Данный системный вызов принимает один аргумент в качестве параметра: указатель на
строку, завершающуюся нулевым байтом и выводит ее на экран. Вывод на экран выполняется по одному
символу, если адрес текущего символа находится вне адресного пространства вызывающего процесса:
произойдет страничное прерывание и процесс будет уничтожен. При достижении конца строки экрана (80 символов),
вывод продолжается со следующей строки. При достижении конца последней строки (25 строка), все строки
сдвигаются на одну вверх (самая первая строка при этом теряется), последняя строка очищается и вывод
продолжается с последней строки.

\paragraph{EXIT.} Данный системный вызов не принимает аргументов. При выполнении системного
вызова текущий процесс уничтожается и освобождаются занятые им системные ресурсы: физические страницы,
дескриптор процесса. Для того, чтобы определить какой процесс выполняется в данный момент (совершил
системный вызов), ядро использует глобальную переменную, которая содержит указатель на дескриптор
текущего процесса. Следует обратить внимание, что системный вызов освобождает только страницы и таблицы
страниц, которые отвечают за отображение виртуальных адресов процесса, т.е. находящихся
в полуинтервале \texttt{[0, USER\_TOP)}. После освобождения всех страниц занятых процессом, ядро устанавливает
статус дескриптора процесса равным \texttt{FREE} и добавляет дескриптор в список свободных
дескрипторов процессов.

\paragraph{YIELD.} Данный системный вызов позволяет процессу добровольно освободить процессор. При
выполнении системного вызова ОС изменяет статус текущего процесса на \texttt{READY} и вызвает
планировщик, который выбирает следующий поцесс и запускает его. Если в очереди больше нет готовых
процессов -- будет снова запущен текущий процесс.

\paragraph{FORK.} Данный системный вызов используется для порождения процессов. При выполнении системного
вызова создается новый процесс (процесс-потомок). Для этого ОС выделяет новый дескриптор из таблицы
дескрпторов процессов и копирует в структуру, описывающую контекст процесса-потомка содержимое структуры,
описывающей контекст процесса-родителя, после чего заносит в регистр RAX, в контекте процесса-потока значение 0.
Таким образом процесс потомок полностью идентичен процессу-родителю, за исключением одного момента: системный вызов
возвращает 0 в процессе-потомке и идентификатор процесса (отличное от 0 значения) в процессе-родителе. Для
клонирования процессов используется механизм копирования при записи (англ. Copy On Write). Все доступные для записи
страницы помечаются как доступные только для чтения, т.е. для них сбрасывается бит <<W>> и устанавливается бит <<COW>>:
это один из неиспользуемых страничным преобразованием бит (11й бит, если считать с 0), доступный для использования
системным ПО. Следует отметить, что после выполнения системного вызова содержимое тиблиц PML4 дочернего и родительского
процессов совпадает.

При попытке записи одним из процессов в страницу доступную только для чтения произойдет страничное исключение.
Обработчик страничного исключения, для страниц у которых установлени бит COW, выделяет новую страницу из списка
свободных страниц и отображает ее в неиспользуемую область виртуального адресного пространства: \texttt{KERNEL\_TEMP},
добавляя права для записи (бит <<W>>). После этого копирует содержимое оригинальной страцы в эту область, удаляет
отображение для оригинальной страницы и отображает вместо него новую страницу. После чего, удаляет отображение для
\texttt{KERNEL\_TEMP}. На рис.~\ref{fig:fork-copy-on-write} показаны основные этапы создания копии процесса.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/fork-copy-on-write}
  \caption{Создание копии процесса и механизм копирования при записи}
  \label{fig:fork-copy-on-write}
\end{figure}

