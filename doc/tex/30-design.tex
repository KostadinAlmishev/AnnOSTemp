\chapter{Конструкторский раздел}
\label{cha:design}

\section{Режимы работы процессора}
Унаследованная (legacy) архитектура x86 предусматривает четыре режима работы процессора:
\begin{enumerate}[1.]
	\item Реальный режим (Real Mode)
	\item Защищенный режим (Protected Mode)
	\item Режим виртуального 8086 (Virtual-8086 Mode)
	\item Режим системного управления (System Management Mode)
\end{enumerate}

Архитектура AMD64 поддерживает все эти режимы и добавляет новый режим,
названный <<длинный>> режим (long mode).

\subsection{Длинный режим}
Длинный режим состоит из двух подрежимов: 64-битного и режима совместимости.
64-битный режим поддерживает несколько новых возможностей, включая возможность
использовать 64-битное адресное пространство. Режим совместимости обеспечивает
бинарную совместимость с существующим 16 и 32-битным прикладным ПО при работе
в 64-битном окружении.

В данном документе ссылки на длинный режим относятся и к 64-битному режиму и к
режиму совместимости. Если какая-то функция доступна только в одном из режимов,
то будет использовано название этого режима.

Перед активацией и переходом в длинный режим, операционная система должна перейти в
защищенный режим. Процесс перехода в длинный режим описан в главе~\ref{sec:long_mode_activation}.

\subsection{64-битный режим}
64-битный режим -- подрежим длинного режима, предусматривает поддержку 64-разрядного
ПО, добавляя следующие возможности:
\begin{enumerate}[1.]
\item 64-битные виртуальные адреса.
\item Доступ к битам 63:32 регистров общего назначения.
\item Дополнительные 8 регистров общего назначения (R8-R15).
\item 64-битный счетчик команд (RIP).
\item Плоская модель памяти с одним сегментом кода, данных и стека.
\end{enumerate}

Данный режим может быть активирован системным ПО для различных сегментов кода. Несмотря
на то, что для включения и выключения 64-битного режима используются сегменты кода,
унаследованный механизм сегментного преобразования адреса использутеся только для проверок доступа.
Для управления памятью используется механизм страничного преобразования.

Размер адреса по умолчанию составляет 64 бита, размер операндов -- 32 бита.

\subsection{Режим совместимости}
Режим совместимости -- подрежим длинного режима, позволяет системному ПО обеспечивать
бинарную совместимость с существущим 16 и 32-битным прикладным ПО,
т.е. запускать данное ПО без перекомпиляции в 64-битной ОС в длинном режим.

В режиме совместимости, приложениям доступны только первые 4 гигабайта виртуального адресного пространства.

Данный режим, как и 64-битный может быть активирован системым ПО для различных сегментов кода.
Однако в режиме совместимости сегментное преобразование адреса работает так же, как и в унаследованной
архитектуре x86. С точки зрения прикладного ПО, режим совместимости не отличается от унаследованного
защищенного режима. С точки зрения системного ПО, используются механизмы длинного режима для преобразования
адресов и обработки исключений и прерываний.

\subsection{Унаследованные режимы}
Унаследованный режим состоит из трех подрежимов: реальный режим, защищенный режим и режим виртуального 8086.
Страничное преобразование в защищенном режиме не является обязательным. Унаследованный режим сохраняет
бинарную совместимость не только с существующим 16 и 32-битным прикладным ПО, но и с существующим 16 и 32-битным
системым ПО.

\subsubsection*{Реальный режим}
В данном режиме, также называемом режимом реальных адресов, процессору доступен 1~мегабайт физической памяти.
Обработка прерываний и формирование адреса выполняется так же, как и реальном режиме процессора 80286.
Страничное преобразование адреса не поддерживается. Все ПО выполняется на нулевом уровне привилегий.

Процессор попадает в реальный режим после сброса (перезагрузки) или при включении. Данный режим не поддерживается,
когда процессор находится в длинном режиме, т.к. в длинном режиме страничное преобразование является обязательным.

\subsubsection*{Защищенный режим}
В данном режиме процессору доступно 4~гигабайта физической и виртуальной памяти. Доступны все возможности
сегментного преобразования и аппаратного переключения задач. Системное ПО может использовать сегментное преобразование
чтобы перемещать эффективные адреса в виртуальном адресном пространстве. Если страничное преобразование выключено --
виртуальные адреса совпадают с физическими.

В защищенном режиме ПО выполняется на уровнях привилегий 0, 1, 2 или 3. Как правило прикладное ПО выполняется на третьем
уровне привилегий, а системное - на 0, 1 и 2.

\subsubsection*{Режим виртуального 8086}
Данный режим позволяет системному ПО запускать 16-битное ПО реального режима на виртуальном процессоре 8086.
В данном режиме ПО, написанное для процессоров 8086, 8088, 80186 и 80188 можно запустить из защищенного режима,
как задачу третьего уровня привилегий. Процессору будет доступен 1~мегабайт виртуального адресного пространства, а
преобразование адресов будет выполняться как в реальном режиме.

Режим не поддерживается, когда процессор находится в длинном режиме (в этом случае попытки перехода в режим
виртуального 8086 игнорируются).

\subsection{Режим системного управления (SMM)}
Режим системного управления -- режим разработанный для действий, связанных с настройкой аппратного обеспечения,
которые <<незаметны>> для обычного системного ПО. Например управление питанием. Данный режим, как правило используется
встроенным программным обеспечением и низкоуровневыми драйверами устройств. Код и данные для SMM сохранены в
области SMM, изолированной от основной памяти.

Вход в SMM осуществляется посредством специального прерывания (SMI). При возникновении SMI процессор переходит
в SMM, переключается на отдельное адресное пространство, в котором находится обработчик SMM и передает ему управление.
В данном режиме процессору доступно 4~гигабайта оперативной памяти; адресация выполняется как и в реальном режиме.

\section{Системные ресурсы}
Операционная система управляет программным окружением и выполняет системные операции используя системные ресурсы.
Эти ресурсы состоят из системных регистров (управляющих и моделезависимых)
и системных структур данных (таблицы для управления адресацией).

\subsection*{Управляющие регистры}
Регистры, которые управляют средой исполнения в AMD64, включают:
\begin{description}
	\item[CR0] Позволяет изменять ражим работы процессора и управляет некоторыми возможностями процессора.
	\item[CR2] Используется механизмом страничного преобразования. При возникновении страничного исключения, содержит
		виртуальный адрес по которому произошло исключение.
	\item[CR3] Используется механизмом страничного преобразования. Содержит базовый адрес таблицы страниц верхнего
		уровня, управляет кешированием данной таблицы.
	\item[CR4] Содержит дополнительные флаги для различных возможностей процессора.
	\item[CR8] Используется для управления приоритетами внешних прерываний.
	\item[RFLAGS] Хранит состояние процессора и некоторые управляющие флаги. В основном используется для
		управления аппаратным переключением задач, прерываниями и режимом виртуального 8086.
	\item[EFER] моделезависимый регистр, содержащий состояние процессора и управляющие флаги, для
		возможностей, которые не управляются регистрами CR0 и CR4.
\end{description}

Управляющие регистры CR1, CR5 -- CR7, CR9 -- CR15 зарезервированы.

В унаследованном режиме все управляющие регистры, в т.ч. RFLAGS -- 32-битные. EFER -- 64-битный во всех режимах.
Архитектура AMD64 расширяет все 32-битные управляющие регистры до 64 бит.

В 64-битном режиме старшие 32 бита регистров CR0 и CR4 зарезервированы и должны быть заполнены нулями.
Запись 1 в один из старших бит приведет исключению общей защиты, \#GP.

Старшие 32 бита регистра RFLAGS всегда равны 0. Попытки записать туда не 0 игнорируются процессором.
Подробное описание полей регистров приведено в \cite[стр. 42]{amd_pm_v2}.

\section{Сегментное преобразование адреса}
Унаследованная архитектура x86 поддерживает механизм сегментного преобразования адреса, который
позволяет системному ПО перемещать инструкции и данные в виртуальном адрсесном пространстве.
Размер и расположение сегмента в виртуальном адресном пространстве произвольны. Инструкции и данные
могут располагаться как в одном, так и в нескольких сегментах, каждому из которых будут назначены
отдельные атрибуты.

Механизм сегментного преобразования предусматривает 10 сегментных регистров, каждый из которых
определяет один сегмент. 6 из этих регистров (CS, DS, ES, FS, GS и SS) определяют пользовательские сегменты.
Пользовательские сегменты содержат команды, данные и стек. Они доступны как для системного, так и для прикладного ПО.
Оставшиеся 4 регистра (GDTR, LDTR, IDTR и TR) определяют системные сегменты. Системные сегменты содержат структуры
данных инициализируемые и используемые только системным ПО. Сегментные регистры содержат базовый адрес, указывающий
на начало сегмента, предел, задающий размер сегмента и атрибиты, определяющие доступ к сегменту.

Несмотря на то, что сегментное преобразование обеспечивает высокую гибкость при перемещении и защите данных,
обычно изоляция и защита адресных пространств выполнятся эффективнее с использованием программной и аппаратной
поддержки страничного преобразования. По этой причине большинство современных систем не используют сегментное преобразование.
Однако механизм сегментного преобразования нельзя полностью отключить, поэтому понимание его работы
является необходимым при разработке ПО для длинного режима.

В длинном режиме, работа сегментного преобразования зависит от того, в каком из подрежимов находится процессор:
\begin{itemize}
\item В режиме совместимости сегментное преобразование работает так же, как и в унаследованном режиме.
\item В 64-битном режиме, сегментное преобразование отключено, задавая плоское 64-битное адресное пространство.
	Однако некоторые функции сегментых регистров (в частности системных сегментных регистров) продолжают использоваться.
\end{itemize}

\subsection{Сегментное преобразование в реальном режиме}
В данном режиме процессору доступен 1~мегабайт физической памяти. 20-битный физичеческий адрес вычисляется
путем сдвига влево на 4~бита 16-битного селектора сегмента и сложения результата с 16-битным эффективным адресом.

Каждый 64-килобайтный сегмент (CS, DS, ES, FS, GS, SS) выровнен по 16-байтной границе. Базовый адрес сегмента это
минимальный адрес в данном сегменте, он равен (селектор сегмента * 16). Для загрузки селекторов в сегментные регистры
можно использовать инструкции POP и MOV.

GDT, LDT и TSS не используются в данном режиме.

\subsection{Сегментное преобразование в защищенном режиме}
Системное ПО может использовать механизм сегментного преобразования для реализации одной из двух основных
моделей: плоская модель памяти и мульти-сегментная модель памяти. Данные модели памяти поддерживаются в
унаследованном режиме и в режиме совместимости.

\subsubsection*{Мульти-сегментная модель памяти}
В данной модели памяти, каждый сегментный регистр может ссылаться на произвольно расположенные в памяти сегменты разных расмеров.
Сегменты могут иметь размер от одного байта до 4х гигабайт. При использовании страничного преобразования, разные сегменты
могут быть отображены на одну страницу и разные страницы могут быть отображены на один сегмент.

Режим совместимости позволяет использовать мульти-сегментную модель памяти для поддержки унаследованного ПО.
Однако в режиме совместимости, мульти-сегментная модель ограничена первыми 4 гигабайтами виртуального
адресного пространства. Для доступа к памяти выше 4х гигабайт, необходимо перейти в 64-битный режим, который
не поддерживает сегментацию.

\subsubsection*{Плоская модель памяти}
Плоская модель памяти -- это простейшая форма сегментного преобразования. Несмотря на то, что сегментное преобразование
не может быть выключено, плоская модель памяти позволяет системному ПО обойти часть механизмов сегментного преобразования.
В плоской модели памяти все базовые адреса сегментов равны 0, а пределы равны 4 гигабайтам. Установка
базового адреса сегмента в 0 фактически отключает сегментное преобразование, приводя к единственному сегменту,
охватывающему все адресное пространство. Все сегментные дескрипторы ссылаются на этот сегмент.

\subsubsection*{Сегментное преобразование в 64-битном режиме}
В 64-битном режиме сегментное преобразование отключено. Аппаратное обеспечение игнорирует значение
базового адреса сегмента и обрабатывает его как 0. Также игнорируются пределы и большинство атрибутов.
Есть несколько исключений. Атрибуты DPL, D и L дескриптора сегмента кода используются соответственно для установки
уровня привилегий, размера операндов по умолчанию и режима работы процессора (64-битный режим или режим совместимости).
Системные сегментные регистры всегда используются в 64-битном режиме.

\subsection{Структуры данных сегментного преобразования}
На рис.~\ref{fig:segmentation-data-structures} показаны следующие структуры данных, используемые
маханизмом сегментного преобразования:
\begin{itemize}
\item Дескрипторы сегментов -- описывают сегменты, включаяя положение сегмента в виртуальном
	адресном пространстве, его размер, атрибуты доступа и некоторые другие характеристики.
\item Таблицы дескрипторов -- сегментные дескрипторы хранятся в памяти в одной из трех таблиц.
	Глобальная таблица дескрипторов (GDT) хранит сегменты, которые могут быть общими для всех задач.
	Можно определить несколько локальных таблиц дескрипторов (LDT) для определенных задач.
	Таблица дескрипторов прерываний (IDT) содержит дескрипторы шлюзов, которые используются
	для доступа к сегментам, в которых расположены обработчики прерываний.
\item Сегмент состояния задачи (TSS) -- специальный тип системного сегмента, который содержит
	информацию о состоянии задачи, в т.ч. ссылки на необходимые задаче структуры данных.
\item Сегментные селекторы -- используются для выборки дескрипторов из таблиц дескрипторов.
	Селектор сегмента содержит в GDT или LDT (в зависимости от атрибутов). В качестве индекса в
	IDT используется номер вектора прерывания.
\end{itemize}

\begin{figure}
  \centering
  \includegraphics[width=0.7\textwidth]{inc/dia/segmentation-data-structures}
  \caption{Струкруты данных сегментного преобразования}
  \label{fig:segmentation-data-structures}
\end{figure}

Механизм сегментного преобразования задействует следующие регистры: CS, DS, ES, SS, GS, FS, GDTR, IDTR, LDTR, TR.
Структуры данных связаны с регистрами следующим образом:
\begin{itemize}
	\item Сегментные регистры -- 6 сегментных регистров (CS, DS, ES, FS, GS, SS) используются чтобы ссылаться
		на пользовательские сегменты. При загрузке селектора сегмента в сегментный регистр процессор
		автоматически загружает выбранный дескриптор в теневую часть сегментного регистра.
	\item Регистры таблиц дескрипторов -- эти регистры (GDTR, LDTR, IDTR) определяют виртуальный базовый адрес и
		размер таблиц дескрипторов.
	\item Регистр задачи -- описывает положение и размер текущего сегмента состояния задачи (TSS).
\end{itemize}

\subsubsection*{Сегментные селекторы}
Селекторы сегментов указывают на дескрипторы в GDT и LDT.
Формат селектора сегмента показан на рис.~\ref{fig:segment-selector}.

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{inc/dia/segment-selector}
  \caption{Формат селектора сегмента}
  \label{fig:segment-selector}
\end{figure}

Селектор состоит из следующих полей:
\begin{enumerate}
\item Индекс селектора. Биты 15:3. Указывает на элемент в таблице дескрипторов.
	Дескрипторы имеют размер 8~байт, поэтому индекс умножается на 8
	чтобы получить смещение в таблице дескрипторов. Смещение прибавляется
	к базовому адресу GDT или LDT (в зависимости от значения TI), чтобы получить
	виртуальный адрес дескриптора.

	Некоторые элементы таблицы дескрипторов имееют размер 16~байт, вместо 8.
	Они занимают 2 элемента в таблице. Однако в длинном режиме смещение по
	прежнему вычисляется путем умножения индекса на 8. Системное ПО должно
	назначать селекторы так, чтобы они указывали на начало расширенных элементов.

\item Индикатор таблицы (TI). Бит 2. Указывает в какой таблице хранится дескриптор.
	Если бит сброшен в 0, это означает что селектор ссылается на запись в GDT.
	Иначе - селектор ссылается на запись в LDT.
\item Уровень привилегий (RPL). Биты 1:0. Равен уровню привилегий на котором
	находился процессор (CPL) при создании селектора. Используется для проверки прав доступа.
\end{enumerate}

Нулевые селекторы, имеющие индекс 0 и TI=0, соответствуют первому элементу в GDT. Используются
чтобы сделать сегментные регистры недействительными. При использовании сегментного регистра (не в 64-битном режиме),
содержащего нулевой селектор произойдет исключение сбоя защиты (\#GP)

Нулевые селекторы можно загружать только в DS, ES, FS, GS и LDTR.

\subsubsection*{Сегментные регистры}
Для любой задачи необходимо чтобы селекторы сегментов были загружены в регистры CS и SS.
Использоние DS, ES, GS и FS является опциональным, однако почти все ПО обращается в данным,
поэтому требует загрузки регистра DS.

Процессор управляет теневой частью сегментного регистра, которая содержит данные из дескриптора
сегмента, соответствующего загруженному селектору. Это используется для улучшения производительности,
т.к. снижает число обращений к памяти.

На рис.~\ref{fig:segment-register-format-x86} показаны видимая и теневая части сегментного регистра.
ПО не имеет прямого доступа к теневой части сегментных регистров (кроме GS и FS).

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{inc/dia/segment-register-format-x86}
  \caption{Формат сегментного регистра}
  \label{fig:segment-register-format-x86}
\end{figure}

В 64-битном режиме теневая часть регистра CS игнориурется, кроме атрибутов D, L и DPL.
При вычислении адреса, базовый адрес считается равным 0, выход за пределы сегмента не проверяется.
Выполняется только одна проверка -- что адрес находится в канонической форме. Теневая часть
регистров DS, ES и SS игнорируется полностью.

\subsection{Таблицы дескрипторов}
Таблицы дескрипторов используются механизмом сегментного преобразования когда активен
защищенный режим (CR0.PE=1). Эти таблицы содержат дескрипторы, которые описывают расположение,
размер и атрибуты доступа сегмента. Все обращения к памяти в защищенном режиме используют
поля дескриптора.

Как было сказано ранее, архитектура x86 поддерживает 3 типа таблиц дескрипторов:
\begin{itemize}
	\item Глобальная таблица дескрипторов (GDT)
	\item Локальная таблица дескрипторов (LDT)
	\item Таблица дескрипторов прерываний (IDT)
\end{itemize}

ПО указывает расположение таблиц в памяти путем модификации регистров таблиц дескрипторов.

\subsubsection*{Глобальная таблица дескрипторов}
Для перехода в защищенный режим необходимо создать GDT. GDT содержит дескрипторы
сегмента кода и сегмента данных (пользовательские сегменты), для сегментов, которые
являются общими для всех задач. Кроме пользовательских сегментов, GDT может содержать
дескрипторы шлюзов и другие системные дескрипторы. Системное ПО может расположить
GDT в произвольном месте в памяти, доступном только привилегированному ПО.

На рис.~\ref{fig:gdt-ldt-access} показано как происходит доступ к GDT/LDT.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/gdt-ldt-access}
  \caption{Доступ к GDT/LDT}
  \label{fig:gdt-ldt-access}
\end{figure}

\subsubsection*{Регистр глобальной таблицы дескрипторов}
Регистр GDT (GDTR) содержит базовый адрес и размер GDT. Регистр загружается командой LGDT.
На рис.~\ref{fig:gdtr-idtr-legacy-format} показан формат GDTR в унаследованном режиме и режиме совместимости.

\begin{figure}
  \centering
  \includegraphics[width=.4\textwidth]{inc/dia/gdtr-idtr-legacy-format}
  \caption{Формат GDTR и IDTR в унаследованном режиме}
  \label{fig:gdtr-idtr-legacy-format}
\end{figure}

На рис.~\ref{fig:gdtr-idtr-x64-format} показан формат GDTR в 64-битном режиме.

\begin{figure}
  \centering
  \includegraphics[width=.9\textwidth]{inc/dia/gdtr-idtr-x64-format}
  \caption{Формат GDTR и IDTR в длинном режиме}
  \label{fig:gdtr-idtr-x64-format}
\end{figure}

GDTR состоит из двух полей:
\begin{description}
\item[Размер] 2 байта. Задает размер GDT в байтах. При обращении ПО за пределы GDT произойдет
	исключение сбоя защиты (\#GP).
\item[Базовый адрес] 8 байт. Содержит виртуальный адрес начала таблицы. GDT может быть расположена
	по любому адресу, однако системному ПО следует использовать адрес, выровненный по 4-байтной границе,
	чтобы избежать снижения производительности из-за доступа к невыровненным данным.

	В архитектуре AMD64 размер базавого адреса в GDTR увеличен до 64 бит, что позволяет системному ПО,
	работающему в длинном режиме, расположить GDT в произвольном месте 64-битного адресного пространства.
	В унаследованном режиме процессор игнорирует старшие 4 байта.
\end{description}

\subsubsection*{Локальная таблица дескрипторов}
Системное ПО после перехода в защищенный режим может создавать локальные таблицы дескрипторов (LDT),
для хранения сегментов принадлежащей одной или нескольким задачам. Как и GDT -- LDT может быть расположена
в произвольной области памяти, доступной только привилегированному ПО.

Дескрипторы LDT хранятся в GDT. Дескриптор LDT хранит базовый адрес таблицы, размер и атрибуты доступа.
Подробное описание формата LDT и LDTR приведено в \cite{amd_pm_v2}.

\subsubsection*{Таблица дескрипторов прерываний}
Системное ПО может определить несколько IDT и переключаться между ними, используя IDTR. Так же как
GDT и LDT -- IDT может быть расположена в произвольной области памяти, доступной только привилегированному ПО.

IDT может содержать дескрипторы следующих типов:
\begin{itemize}
	\item Шлюз прерывания (interrupt gate)
	\item Шлюз ловушки (trap gate)
	\item Шлюз задачи (task gate)
\end{itemize}

Использование дескрипторов шлюзов механизмом прерываний описано в главе~\ref{sec:exceptions_and_interrupts}.

Обращение к элемента IDT происходит по номеру вектора прерывания. Смещение в таблице вычисляется путем
умножения номера вектора прерывания на размер элемента таблицы. Размер элемента таблицы зависит от
режима работы процессора следующим образом:
\begin{itemize}
\item В длинном режиме -- размер элемента IDT составляет 16 байт.
\item В унаследованном режиме -- размер элемента IDT составляет 8 байт.
\end{itemize}

На рис.~\ref{fig:indexing-an-idt} как происходит индексация в IDT по номерy вектора прерывания.

\begin{figure}
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/indexing-an-idt}
  \caption{Индексация в IDT}
  \label{fig:indexing-an-idt}
\end{figure}


\subsubsection*{Регистр таблицы дескрипторов прерываний}
Регистр таблицы дескрипторов прерываний (IDTR) содержит базовый адрес и размер IDT.
Содержимое регистра загружается командой LIDT. Формат IDTR совпадает с форматов GDTR во
всех режимах работы процессора. На рис.~\ref{fig:gdtr-idtr-legacy-format} показан формат
IDT в унаследованном режиме, а на рис.~\ref{fig:gdtr-idtr-x64-format} -- в длинном режиме.

\subsection{Унаследованные дескрипторы сегментов}
\subsubsection*{Формат дескриптора}
Дескрипторы сегментов определяют и изолируют сегменты друг от друга. Существует 2 основных типа
дескрипторов, каждый из которых используется для описания сегментов (шлюзов) разных типов:
\begin{itemize}
\item Пользовательские сегменты -- сегмент кода и сегмент данных. Сегменты стека относятся к сегментам данных.
\item Системные сегменты -- сюда входят LDT, TSS. Дескрипторы шлюзов также являются системным сегментами, но
	они описывают программные точки входа.
\end{itemize}

На рис.~\ref{fig:legacy-segment-descriptor-format} показан общий формат дескриптора сегмента в унаследованном режиме.
В унаследованном режиме размер сегмента составляет 8 байт (2 двойных слова). На рисунке старшее двойное слово (смещение +4)
изображено вверху, младшее -- внизу.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/legacy-segment-descriptor}
  \caption{Общий формат дескриптора в унаследованном режиме}
  \label{fig:legacy-segment-descriptor-format}
\end{figure}

Дескриптор имеет следующие поля:
\begin{itemize}
\item Размер сегмента. 20-битный размер сегмента формируется путем объединения
	бит 19:16 старшего двойного слова и 0:15 младшего двойного слова. Задает размер сегмента
	в байтах. Для сегментов данных бит E определяет какую границу сегмента задает данное поле,
	верхнюю или нижнюю.
\item Базовый адрес. 32-битный базовый адрес формируется путем объединения бит 31:24 старшего двойного слова,
	7:0 этого же двойного слова и 15:0 младшего двойного слова. Содержит адрес начала сегмента в
	виртуальной памяти.
\item Бит S. Если равно 0 -- системный сегмент (LDT, TSS, шлюз), иначе -- пользовательский (код, данные).
\item Тип. Определяет тип сегмента. Конкретные значения будут рассмотрены далее.
\item DPL. Определят уровень привилегий дескриптора. Может иметь значения от 0 до 3, где 0 -- наибольший
	уровень привилегий, 3 -- наименьший.
\item Бит P. Определяет присутствует (загружен) ли сегмент в памяти. Если произойдет обращение к сегменту,
	у которого этот бит равен 0 -- произойдет исключение \#NP. Процессор никогда не изменяет значение
	этого бита, это делает только системное ПО.
\item AVL. Доступно системному ПО. Процессора никогда не изменяет это поле.
\item Бит D/B. Размер операнда по умолчанию. Используется для сегментов данных и сегментов кода.
	Если равен 1 -- размер операндов по умолчанию составляет 32 бита, иначе -- 16 бит.
\item Бит G. Бит гранулярности -- опредяет как обрабатывать размер сегмента. Если равен 0 -- размер сегмента
	задается в байтах. Если равен 1 -- размер сегмента задан в 4-килобайтных блоках.
\end{itemize}

\subsubsection*{Дескрипторы сегмента кода}
На рис.~\ref{fig:legacy-code-segment-descriptor-format} показан формат дескриптора сегмента кода. Для
всех программных задач необходимо чтобы селектор, ссылающийся на корректный сегмент кода был загружен в регистр CS.
Сегменты кода определяют режим работы процессора и уровень привилегий. Сегменты кода доступны только для исполнения,
либо только для чтения и исполнения. Запись в сегмент, на который ссылается регистр CS запрещена.
\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/legacy-code-segment-descriptor}
  \caption{Формат дескриптора сегмента кода в унаследованном режиме}
  \label{fig:legacy-code-segment-descriptor-format}
\end{figure}

Для дескрипторов сегментов кода бит S установлен в 1, означая что это пользовательский сегмент. Бит 11
используется чтобы отличать сегменты кода и сегменты данных (если бит установлен в 1 -- это сегмент кода,
в противном случае -- это сегмент данных). Биты 10:8 определяют характеристики доступа к сегменту кода:
\begin{itemize}
	\item Бит C. Процессор не меняет текущий уровень привилегий (CPL), если происходит передача управления
		сегмент с более высоким уровнем привилегий, у которого бит C=1.
	\item Бит R. Если установлен в 1 -- сегмент доступен для чтения и исполнения. В противном случае --
		только для исполнения (при попытке чтения произойдет исключение \#GP).
	\item Бит A. Устанавливается в 1 при копировании дескриптора из GDT или LDT в регистр CS. Сбрасывается
		только системным ПО.
\end{itemize}

Бит D. В дескрипторах сегментов кода этот бит определяет размер операндов и адреса по умолчанию.
Если он сброшен в 0 -- размер по умолчанию состаляет 16 бит, в противном случае -- 32 бита.

\subsubsection*{Дескрипторы сегмента данных}
На рис.~\ref{fig:legacy-data-segment-descriptor-format} показан формат дескриптора сегмента кода.
Сегменты данных могут быть доступны либо только для чтения, либо для чтения/записи. Доступ к сегментам
данных осуществляется с использованием регистров DS, ES, FS, GS, SS. Регистр DS содержит селектор
сегмента данных, используемый по умолчанию. Сегментные регистры ES, FS, GS могут содержать селекторы
дополнительных сегментов данных, используемых текущей задачей.

Сегмент стека это одна из форм сегмента данных. Доступ к нему осуществляется через регистр SS. Он должен
быть доступен для чтения и записи.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/legacy-data-segment-descriptor}
  \caption{Формат дескриптора сегмента данных в унаследованном режиме}
  \label{fig:legacy-data-segment-descriptor-format}
\end{figure}

Для дескрипторов сегментов данных бит S установлен в 1, означая что это пользовательский сегмент. Бит 11
сброшен в 0, обозначая сегмент данных. Биты 10:8 определяют характеристики доступа к сегменту:
\begin{itemize}
	\item Бит E. Если этот бит установлен в 1 -- значит это расширяющийся вниз сегмент. В этом случае
		поле <<размер>> определяет нижнюю границу сегмента, а поле <<базовый адрес>> -- верхнюю.
		Это может быть полезно для сегмента стека (т.к. указатель стека растет в сторону уменьшения адресов).
	\item Бит W. Если бит установлен в 1 -- сегмент доступен для записи. В противном случае попытка записи
		приведет к исключению \#GP.
	\item Бит A. Устанавливается в 1 при копировании дескриптора из GDT или LDT в сегментный регистр данных или стека.
		Сбрасывается только системным ПО.
\end{itemize}

\subsection{Сегментные дескрипторы длинного режима}
В длинном режиме некоторые поля дескрипторов сегментов интепретируются иначе. Формат некоторых дескрипторов расширен.
Изменеия зависят от режима работы процессора (режим совместимости или 64-битный режим) и от типа дескриптора.

\subsubsection*{Дескрипторы сегмента кода}
В длинном режиме сегменты кода продолжают использоваться. Сегменты кода, их дескрипторы и селекторы
необходимы для установки режима работы процессора и уровня привилегий. Новый атрибут L определяет в
каком режиме работает процессор -- в 64-битном или режиме совместимости. На рис.~\ref{fig:long-mode-code-segment-descriptor-format}
показан формат дескриптора сегмента кода в длинном режиме. В режиме совместимости все поля дескриптора
интерпретируются также, как и в унаследованном режиме.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-code-segment-descriptor}
  \caption{Формат дескриптора сегмента кода в длинном режиме}
  \label{fig:long-mode-code-segment-descriptor-format}
\end{figure}

\paragraph{Игнорируемые в 64-битном режиме поля.}
В 64-битном режиме сегментное преобразование отключено, сегменты кода занимают все адресное пространство.
В этом режим поле <<базовый адрес>> игнорируется. При вычислении виртуального адреса это поле считается равным 0.

Проверка выхода за границу сегмента не выполняется, игнорируются размер и бит G. Вместо этого выполняется
проверка что адрес находится в канонической форме.

Также игнорируются биты R, A в поле <<тип>>.

\paragraph{Бит L.} В длинном режиме у дескриптора кода появился новый атрибут -- бит L. Если он равен 1 --
процессор работает в 64-битном режиме, иначе -- в режиме совместимости. В унаследованном режиме этот бит игнорируется.

Режим совместимости имеет бинарную совместимость с существующим 16 и 32-битным прикладным ПО.
Переход в режим совместимости осуществялется на основании атрибутов сегмента кода, это позволяется
64-битному системному ПО исполнять унаследованное ПО вместе с 64-битным ПО. Для запуска унаследованных
16 и 32-битных приложений системному ПО достаточно сбросить бит L в дескрипторе сегмента кода в 0.

Если процессор работает в 64-битном режиме (L=1) -- бит D должен быть равен 0. Это приводит к тому,
что размер операнда по умолчанию составляет 32 бита, а размер адреса по умолчанию составляет 64 бита.
Комбинация L=1 и D=1 зарезервирована для использования в будущем.

\subsubsection*{Дескрипторы сегмента данных}
В длинном режиме сегменты данных продолжают использоваться. На рис.~\ref{fig:long-mode-code-segment-descriptor-format}
показан формат дескриптора сегмента данных в длинном режиме. В режиме совместимости все поля дескриптора
интерпретируются также, как и в унаследованном режиме.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-data-segment-descriptor}
  \caption{Формат дескриптора сегмента данных в длинном режиме}
  \label{fig:long-mode-data-segment-descriptor-format}
\end{figure}

\paragraph{Игнорируемые в 64-битном режиме поля.}
В 64-битном режиме сегментное преобразование отключено. Интерпретация базового адреса зависит от
используемого сегментного регистра:
\begin{itemize}
\item При использовании регистров DS, ES, SS поле <<базовый адрес>> игнорируется и считается равным 0.
\item Регистры GS и FS обрабатываются специальным образом. При использовании этих регистров можно
	использовать ненулевое значение базового адреса для вычисления виртуального адреса.
\end{itemize}

Проверка выхода за границу сегмента не выполняется, игнорируются размер и бит G. Бит <<D/B>> не
используется в 64-битном режиме.

Биты E, W и A игнорируются.

Поле DPL также игнорируется, проверки доступа к сегментам данных не выполняются.
Системное ПО может использовать механизм страничной защиты для ограничения доступа в данным.

\subsubsection*{Системные дескрипторы}
\label{subsec:system_desriptor_format}

Как показано на рис.~\ref{fig:long-mode-system-segment-descriptor-format} в 64-битном режиме
системные дескрипторы LDT и TSS увеличены на 64 бита. Увеличение дескрипторов, позволяет
хранить в них 64-битный базовые адреса, поэтому сегменты, которые они описывают могут быть
расположены в произвольном месте в памяти. Расширенные дескрипторы могут быть загружены в
соответствующие регистры (LDTR или TR) только из 64-битного режима.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-system-segment-descriptor}
  \caption{Формат дескриптора сегмента данных в длинном режиме}
  \label{fig:long-mode-system-segment-descriptor-format}
\end{figure}

Базовый адрес 64-битного системного сегмента должен быть в канонической форме, иначе при
загрузке сегмента произойдет исключение \#GP(селектор). Размер системного сегмента проверяется и
в 64-битном режиме и в режиме совместимости с учетом бита гранулярности (G).

На рис.~\ref{fig:long-mode-system-segment-descriptor-format} показано, что биты 12:8 двойного слова +12
должны быть сброшены в 0. Эти биты соотвествуют биту S и полю <<тип>> в унаследованном дескрипторе.
Сброс этих бит в 0 соответствует неправильному типу дескриптора в унаследованном режиме и приведет
к возникновению исключения \#GP при попытке обратиться отдельно к старшей половине 64-битного системного сегмента.

\subsubsection*{Дескрипторы шлюзов}
В длинном режиме, дескрипторы шлюзов увеличены на 64 бита, что позволяет хранить в них 64-битные смещения.
Формат 64-битного дескриптора шлюза прерывания и шлюза ловушки показан на рис.~\ref{fig:long-mode-interrupt-gate-descriptor}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-interrupt-gate-descriptor}
  \caption{Формат дескриптора шлюза прерывания и шлюза ловушки в длинном режиме}
  \label{fig:long-mode-interrupt-gate-descriptor}
\end{figure}

Селектор сегмента (в дескрипторе шлюза) должен указывать на 64-битный сегмент кода (CS.L=1, CS.D=0).
В противном случае будет вызвано исключение \#GP.

Исключение также возникает, если адрес, содержащийся в поле <<смещение>>, находится не в канонической форме.

В 64-битном режиме элементы таблицы векторов прерываний имеют размер 64 бита. Процессор автоматически
умножает номер вектора прерывания на 16 для определения смещения.

\paragraph{Поле <<IST>>.} Биты 2:0 байта +4. В длинном режиме в дескрипторах шлюзов прерываний и ловушек
появилось новое 3-битное поле -- IST. Данное поле используется в качестве индекса в IST фрагменте TSS длинного режима.
Если IST не равно 0 -- индекс ссылается на элемент IST в TSS, значение которого процессор загружает в регистр RSP при
возникновении прерывания. Если IST равно 0 -- процессор использует унаследованный механизм переключения стека.

\subsection{Защита сегментов}
Архитектура AMD64 разработана, чтобы полностью поддерживать унаследованный механизм защиты сегментов.
Данный механизм позволяет системному ПО ограничивать программам доступ к данным и процедурам других программ.

Защита на уровне сегментов включена в режиме совместимости. 64-битный режим устраняет часть проверок,
оставляя только проверки доступа к таблицам системных дескрипторов.

Предпочтительный метод организации защиты памяти в операционной системе длинного режима -- использование
механизма страничного преобразования. Системному ПО по прежнему необходимо создать основные структуры
данных для сегментного преобразования в 64-битном режиме. Однако эти структуры упрощены, из-за использования
плоской модели памяти в 64-битном режиме и отсутствия некоторых проверок.

\subsubsection*{Концепция уровней доступа}
Механизм защиты сегментов используется изолировать и защищать код и данные различных программ. В защищенном
режиме данный механизм поддерживает 4 уровня привилегий. Уровни привилегий обозначаются номерами от 0 до 3,
где 0 -- наивысший уровень привилегий, 3 -- наименьший. Системное ПО обычно назначает уровни привилегий
следующим образом:
\begin{itemize}
\item Уровень 0. Этот уровень используется критичными компонентами системного ПО, которым
	необходим прямой доступ и контроль над всеми процессорными и системными ресурсами.
	Сюда входит встроенное ПО, функции управления памятью и обработка прерываний.
\item Уровень 1 и 2. Эти уровни используются менее критичными компонентами системного ПО,
	которым необходим доступ к ограниченному набору процессорных и системных ресурсов.
	Сюда входят драйверы устройст и библиотечные функции. Функции данного уровня могут
	использовать функции более высокого уровня привилегий для работы с памятью и файлами.
\item Уровень 3. Этот уровень используется прикладным ПО. Доступ к системным ресурсам осуществляется
	через системные вызовы.
\end{itemize}

На рис.~\ref{fig:privilege-levels} показаны отношения между уровнями привилегий.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.7\textwidth]{inc/dia/privilege-levels}
  \caption{Формат дескриптора шлюза прерывания и шлюза ловушки в длинном режиме}
  \label{fig:privilege-levels}
\end{figure}

\subsubsection*{Типы уровней привилегий}
Существует три типа уровней привилегий, используемых процессором для контроля доступа к сегментам.
Это CPL, DPL и RPL.

\paragraph{CPL.} Текущий уровень привилегий -- уровень привилегий, на котором процессор находится в данный
момент. Он хранится во внутреннем регистре процессора, недоступном для ПО. Изменить текущий уровень привилегий
можно путем передачи управления на сегмент кода с другим уровнем привилегий.

\paragraph{DPL.} Уровень привилегий дескриптора -- уровень привилегий, который системное ПО назначает сегменту (шлюзу).
Используется при проверке прав доступа, чтобы определить можно ли приложению обращаться к сегменту (шлюзу), на который
ссылается дескриптор. Данное поле хранится в дескрипторе сегмента (шлюза).

\paragraph{RPL.} Отражает уровень привилегий процесса, который создал селектор сегмента/шлюза. RPL может быть использован
в вызываемой программе, чтобы определить уровень привилегий вызывающей программы. Данное поле хранится
в селекторе сегмента/шлюза.

Как происходит проверка прав доступа с использованием CPL, DPL и RPL рассказано в \cite{amd_pm_v2}.

\section{Страничное преобразование}
% FIXME

\section{Сегмент состояния задачи (TSS)}
\subsection{Аппаратная многозадачность}
Задача (также называемая процессом) это программа, которую процессор может
исполнять, приостанавливать и позже продолжать исполнение с места последней
остановки. Пока задача приостановлена могут исполняться другие задачи. Каждая
задача имеет свой контекст, в который входят:
\begin{enumerate}
\item Сегмент кода и IP (указатель на следующую инструкцию)
\item Сегменты данных
\item Сегменты стека для всех уровней привилегий
\item Регистры общего назначения
\item Регистр флагов (rFLAGS)
\item Локальная таблица дескрипторов
\item Регистр задачи и указатель на предыдущую задачу
\item Битовые карты разрешений ввода/вывода и прерываний
\item Указатель на таблицу страничного преобразования верхнего уровня (CR3)
\end{enumerate}

В защищенном режиме работы процессора эта информация сохранялась в
сегменте состояния задачи (TSS) для возможности аппаратного переключения
задач~\cite[стр. 327]{amd_pm_v2}.

\subsection{Ресурсы управления задачами}
В <<длинном>> режиме аппаратное переключение задач не поддерживается, но
операционная система по прежнему должна инициализировать некоторые ресурсы
управления задачами:
\begin{enumerate}
\item Сегмент состояния задачи (TSS) -- сегмент, в котором хранится состояние
	процессора, связанное задачей.
\item Дескриптор TSS -- дескриптор сегмента, описывающий TSS.
\item Селектор TSS -- селектор сегмента, который ссылается на дескриптор TSS,
	расположенный в GDT.
\item Регистр задачи (TR) -- регистр, в котором хранится селектор и дескриптор
	TSS текущей задачи.
\end{enumerate}

На рис.~\ref{fig:task_management_resources} показано как связаны между собой
эти ресурсы в <<длинном>> режиме.
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/task-management-resources}
  \caption{Ресурсы управления задачами}
  \label{fig:task_management_resources}
\end{figure}

\subsubsection*{Селектор TSS}
Селекторы TSS это селекторы, которые указывают на дескрипторы TSS в GDT.
Формат селектора TSS совпадает с форматом других сегментных селекторов и
показан на рис.~\ref{fig:tss_selector}.

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{inc/dia/tss-selector}
  \caption{Формат селектора TSS}
  \label{fig:tss_selector}
\end{figure}

Селектор состоит из следующих полей:
\begin{enumerate}
\item Индекс селектора. Биты 15:3. Определяет смещение дескриптора TSS в GDT.
\item Индикатор таблицы (TI). Бит 2. Данный бит должен быть сброшен в 0, это
	означает что селектор ссылается на запись в GDT. Дескрипторы TSS
	запрещено размещать в LDT и при попытки обратиться к дескриптору TSS,
	расположенному в LDT произойдет сбой защиты (\#GP).
\item Уровень привилегий (RPL). Биты 1:0. Равен уровню привилегий на котором
	находился процессор при загрузке селектора TSS в регистр задачи (TR).
\end{enumerate}

\subsubsection*{Дескриптор TSS}
Дескриптор TSS это системный дескриптор, который может быть расположен только
в GDT. Его формат описан ранее в \ref{subsec:system_desriptor_format}.

TSS должен иметь размер минимум 104 байта (т.е. минимальное значение поля <<предел>> -- 103).
Если размер TSS меньше -- при переключении задач будет сгенерировано
исключение <<неверный TSS (\#TS)>>.

\subsubsection*{Регистр задачи (TR)}
Регистр задачи хранит адрес TSS, определяет его размер и атрибуты. TR состоит
из двух частей -- видимой и теневой. В видимой (доступной для ПО) части хранится селектор TSS,
теневая часть содержит дескриптор TSS. При загрузке селектора TSS в TR
процессор автоматически загружает дескриптор TSS из GDT в теневую часть.
Загрузка нового значения в TR осуществляется инструкцией LTR. На
рис.~\ref{fig:task_register} показан формат TR в <<длинном>> режиме.

\begin{figure}
  \centering
  \includegraphics[width=.8\textwidth]{inc/dia/task-register}
  \caption{Формат регистра задачи (TR)}
  \label{fig:task_register}
\end{figure}

\subsubsection*{Формат TSS}
Несмотря на то, что аппаратный механизм переключения задач не поддерживается в
<<длинном>> режиме, 64х-битный TSS должен быть объявлен. Системное ПО должно
создать как минимум один TSS для использования в <<длинном>> режиме и
выполнить инструкции LTR в 64х-битном режиме, чтобы загрузить в TR 64-х битный
TSS.

На рис.~\ref{fig:tss} показан формат TSS в <<длинном>> режиме. TSS включает
следующую информацию:
\begin{enumerate}
\item RSPn -- Байты 0x1B-0x04. 64-битные адреса указателей стека (RSP) для
	уровней привилегий 0,1 и 2.
\item ISTn -- Байты 0x5B-0x24. 64-битные адреса указателей стека, используемые
	при включенном механизме IST.
\item Базовый адрес битовой карты разрешений ввода/вывода. Байты 0x67-0x66.
\end{enumerate}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/tss}
  \caption{Формат TSS}
  \label{fig:tss}
\end{figure}



\section{Исключения и прерывания}
\label{sec:exceptions_and_interrupts}

Исключения и прерывания приводят к передаче управления функциям операционной
системы. Эти функции называются обработчиками исключений и обработчиками
прерываний. Обычно прерывания обрабатываются незаметно для прерванной
программы. Во время передачи управления обработчику прерываний процессор
перестает выполнять прерванную программу и сохраняет адрес возврата.
Обработчик прерывания или исключения отвечает за сохранение контекста
прерванной программы. Это позволяет процессору продолжить исполнение
программы, после того как обработчик прерывания (исключения) завершится.

При возникновении прерывания или исключения процессор использует номер
прерывания как индекс в таблице дескрипторов прерываний (IDT). IDT
используется во всех режимах работы процессора, включая реальный режим (real
mode), защищенный режим (protected mode) и длинный режим (long mode).

Прерывания можно резделить на 3 категории~\cite{amd_pm_v2}: исключения,
программные прерывания и внешние прерывания.

Исключения (exceptions) возникают в результате ошибок во время исполнения ПО или внутренних
ошибок процессора. Исключения также могут возникать без наличия ошибочных
ситуаций, например при пошаговом выполнении программы. Исключения считаются
синхронными событиями, т.к. они возникаются в результате исполнения прерванной
инструкции.

Программные прерывания (software interrupts) возникаются в результате вызова прерывания (int). В
отличие от исключений и внешних прерываний, программные прерывания позволяют
намеренно вызывать обработчики прерываний. Как и исключения, программные
прерывания являются синхронными событиями.

Внешние прерывания (external interrupts) генерируются системой в результате возникновения ошибки
или какого-либо события вне процессора. Они доставляются на шину процессора
используя внешние сигналы. Внешние прерывания являются асинхронными событиями,
т.к. они возникают независимо от прерванной инструкции.

\subsection{Основные характеристики}
Исключения и прерывания имеют несколько различных характеристик, которые
зависят от того как они были доставлены и определяют как следует продолжить выполнение
прерванной программы.

\subsubsection*{Точность}
По отношению к прерванной инструкции прерывания делятся на:
\begin{itemize}
\item Точные прерывания возникают на предсказуемой границе. Эта граница
как правило -- первая инструкция, которая не была выполнена во время
возникновения прерывания. Все предыдущие инструкции были завершены перед
передачей управления обработчику прерывания. Указатель на граничную инструкцию
автоматически сохраняется процессором. Когда обработчик прерывания
завершается, он возвращается в прерванную программу и исполнение продолжается
с граничной инструкции.
\item Неточные. Не гарантируется возникновение на предсказуемой границе.
Границей может быть любая инструкция, которая не была завершена во время
возникновения прерывания. Неточные события можно считать асинхронными, т.к.
источник прерывания может быть не связан с исполняемой инструкцией.
Обработчики неточных прерываний и исключений обычно собирают информацию о
состоянии системы и передают специально программному обеспечению для
диагностики. Выполнение прерванной программы не продолжается.
\end{itemize}

\subsubsection*{Перезапуск инструкций}
Как было сказано выше, точные исключения возникают на границе инструкции. Эта
граница может находиться либо перед, либо после инструкции.

Для большинства исключений граничной является инструкция вызвавшая исключение,
т.е. граница устанавливается перед этой инструкцией. В этом случае все
инструкции предсшествующие данной (в програмном порядке) считаются
выполненными. Состояние программы не изменилось в процессе частичного
выполнения преванной инструкции.

Есть исключения для которых граничной является инструкция следующая за той,
которая вызвала исключение. В этом случае все предыдущие инструкции, включая
ту, которая вызывала исключение, считаются выполненными.

Состояние программы может быть изменено, когда граничной инструкцией является
инструкция, следующая за вызвавшей исключение. В частности такое может
произойти, когда исключение произошло в результате переключения задач. В этом
случае регистры общего назначения, сегментные регистры, CR3 и LDTR были обновлены
аппаратным мехазнимом переключения задач. Однако такое не может произойти в
"длинном режиме", т.к. в нем выключен механизм аппаратного переключения задач.

\subsubsection*{Типы исключений}
Исключения можно разделить на 3 типа в зависимости от того, являются ли они
точными и как они влияют на продолжение работы программы:
\begin{enumerate}
\item Ошибки (faults) -- являются точными исключениями возникающими на границе перед
инструкцией, вызвавшей исключение. Все изменения, вызванные данной инструкцией
отменются, поэтому инструкция может быть перезапущена.
\item Ловушки (traps) -- являются точными исключениями, возникающими на границе после
инструкции, вызвавшей исключение. Процессор полностью выполнил инструкцию,
вызвавшую исключение, т.о. все изменения, вызванные инструкцией сохранены.
rIP указывает на инструкцию, следующую за той, которая вызвала исключение.
\item Аварии (aborts) -- неточные инструкции, поэтому обычно они не позволяют
продолжить правильное выполнение программы.
\end{enumerate}

\subsubsection*{Маскирование внешних прерываний}
Программное обеспечение может маскировать некоторые прерывания и исключения.
Маскирование может задержать или не допустить запуск механизма обработки
прерываний при возникновении прерывания. Внешние прерывания можно разделить на
маскируемые и немаскируемые.

Маскируемые прерывания приводят к вызову обработчика прерывания только если
RFLAGS.IF=1. В противном случае они не доставляются до тех пор, пока RFLAGS.IF
не станет равные 0.

Немаскируемые прерывания (NMI) обрабатываются независимо от значения RFLAGS.IF.
Однако при возникновении NMI прерывания, последующие NMI прерывания будут
замаскированы до выполнения инструкции IRET.

\subsubsection*{Маскирование при переключение стека}
Процессор откладывает обработку маскируемых прерываний и отладочных исключений
при выполнении определенных последовательностей инструкций, которые обычно
используются программным обеспечением для переключения стека. Стандартная
последовательность, используемая при переключении стека выглядит следующим
образом:
\begin{enumerate}
\item Загруить селектор сегмента стека в регистр SS
\item Загрузить смещение начала стека в регистр ESP
\end{enumerate}

Если прерывание возникает после того, как загружен SS, но до загрузки ESP -
указатель стека прерванной программы будет неверным во время выполнения
обработчика прерывания.

Чтобы недопустить проблем с указателем стека, вызванных прерываниями,
процессор не обрабатывает внешние прерывания и отладночные исключения пока
инструкция следующая за MOV SS или POP SS не будет выполнена.

\subsubsection*{Отключение исключений}
Отключение исключений предотвращает обнаружение исключительных ситуаций, в
отличие от маскирования исключений, которое предотвращает запуск механизма
обработки исключительной ситауции после того, как она была обнаружена.
Некоторые исключения могут быть отключены системным программным обеспечением,
выполняющемся на нулевом уровне привилегий, используя биты в регистрах CR0 и
CR4.

Механизм отладочных исключений позволяет контролировать, когда определнные
точки останова включены и когда они выключены.

\subsection{Векторы прерываний}
Определенным исключениям и прерываниям назначены фиксированные номера (также
называемые векторами прерываний или просто векторами). Вектор прерывания
используется механизмом обработки прерываний для определения точки входа в
обработчик прерывания. Можно использовать до 256 векторов прерываний. Первые 32 вектора
зарезервированы для преопределенных прерываний и исключительных ситуаций.
Для программных прерываний можно использовать любые из свободных векторов.

В таблице~\ref{tab:interrupts} перечислены поддерживаемые номера прерываний, их названия,
мнемонические обозначения и краткое описание.

\begin{center}
    \begin{longtable}{|c|p{0.30\textwidth}|p{0.20\textwidth}|p{0.30\textwidth}|}
    \caption{Описание прерываний}
    \label{tab:interrupts}
    \\ \hline
    Вектор & Название & Мнемоническое обозначение & Причины возникновения \\
    \hline \endfirsthead
    \subcaption{Продолжение таблицы~\ref{tab:interrupts}}
    \\ \hline \endhead
    \hline \subcaption{Продолжение на след. стр.}
    \endfoot
    \hline \endlastfoot
    0   & Divide-by-Zero-Error & \#DE & Инструкции DIV, IDIV, AAM \\
    \hline
    1   & Debug & \#DB & Доступ к инструкциям и данным \\
    \hline
    2   & Non-Maskable-Interrupt & \#NMI & Внешний сигнал NMI \\
    \hline
    3   & Breakpoint & \#BP & Инструкция INT3 \\
    \hline
    4   & Overflow & \#OF & Инструкция INTO \\
    \hline
    5   & Bound-Range & \#BR & Инструкция BOUND \\
    \hline
    6   & Invalid-Opcode & \#UD & Неверные инструкции \\
    \hline
    7   & Device-Not-Available & \#NM & Инструкции x87 \\
    \hline
    8   & Double-Fault & \#DF & Исключение возникшее во время обработки
    другого исключения или прерывания \\
    \hline
    9   & Coprocessor Segment Overrun & --- & Не поддерживается
    (зарезервировано) \\
    \hline
    10  & Invalid-TSS & \#TS & Доступ к сементу состояния задачи (TSS) \\
    \hline
    11  & Segment-Not-Present & \#NP & Загрузка сегментного регистра \\
    \hline
    12  & Stack & \#SS & Загрузка SS и обращение к стеку \\
    \hline
    13  & General-Protection & \#GP & Доступ к памяти с различные проверки \\
    \hline
    14  & Page-Fault & \#PF & Доступ к памяти при включенном страничном
    преобразовании \\
    \hline
    15  & Зарезервировано & --- & --- \\
    \hline
    16  & x87 Floating-Point Exception-Pending & \#MF & Инструкции x87 \\
    \hline
    17  & Alignment-Check & \#AC & Доступ к памяти по невыровненным адресам \\
    \hline
    18  & Machine-Check & \#MC & Зависит от модели процессора \\
    \hline
    19  & SIMD Floating-Point & \#XF & SSE инструкции \\
    \hline
    20-29  & Зарезервировано & --- & --- \\
    \hline
    30  & Security Exception & \#SX & События связанныие с безопасностью \\
    \hline
    31  & Зарезервировано & --- & --- \\
    \hline
    0-255  & External Interrupts (Maskable) & \#INTR & Внешние прерывания \\
    \hline
    0-255  & Software Interrupts & --- & Инструкции INTn \\
    \hline
  \end{longtable}
\end{center}

В таблице~\ref{tab:interrupts_classification} приведена классификация векторов
прерываний.

\begin{center}
    \begin{longtable}{|c|p{0.30\textwidth}|c|c|}
    \caption{Классификация векторов прерываний}
    \label{tab:interrupts_classification}
    \\ \hline
    Вектор & Название & Тип & Точность \\
    \hline \endfirsthead
    \subcaption{Продолжение таблицы~\ref{tab:interrupts_classification}}
    \\ \hline \endhead
    \hline \subcaption{Продолжение на след. стр.}
    \endfoot
    \hline \endlastfoot
    0   & Divide-by-Zero-Error & Ошибка & Точное \\
    \hline
    1   & Debug & Ошибка или ловушка & Точное \\
    \hline
    2   & Non-Maskable-Interrupt & -- &  -- \\
    \hline
    3   & Breakpoint & Ловушка & Точное \\
    \hline
    4   & Overflow & Ловушка & Точное \\
    \hline
    5   & Bound-Range & Ошибка & Точное \\
    \hline
    6   & Invalid-Opcode & Ошибка & Точное \\
    \hline
    7   & Device-Not-Available & Ошибка & Точное \\
    \hline
    8   & Double-Fault & Авария & Не точное \\
    \hline
    9   & Coprocessor Segment Overrun & --- & --- \\
    \hline
    10  & Invalid-TSS & Ошибка & Точное \\
    \hline
    11  & Segment-Not-Present & Ошибка & Точное \\
    \hline
    12  & Stack & Ошибка & Точное \\
    \hline
    13  & General-Protection & Ошибка & Точное \\
    \hline
    14  & Page-Fault & Ошибка & Точное \\
    \hline
    15  & Зарезервировано & --- & --- \\
    \hline
    16  & x87 Floating-Point Exception-Pending & Ошибка & Не точное \\
    \hline
    17  & Alignment-Check & Ошибка & Точное \\
    \hline
    18  & Machine-Check & Авария & Не точное \\
    \hline
    19  & SIMD Floating-Point & Ошибка & Точное \\
    \hline
    20-29  & Зарезервировано & --- & --- \\
    \hline
    30  & Security Exception & --- & Точное \\
    \hline
    31  & Зарезервировано & --- & --- \\
    \hline
    0-255  & External Interrupts (Maskable) & --- & --- \\
    \hline
    0-255  & Software Interrupts & --- & --- \\
    \hline
  \end{longtable}
\end{center}

\subsubsection*{\#DE Деление на 0 (Вектор 0)}
Возникает когда делитель в инструкциях DIV и IDIV равен 0. Так же возникает,
когда не помещается в регистры назначения. Данное исключение не может быть
выключено.

Не возвращает код ошибки. Сохраненный IP указывает на инструкцию, вызвавшую
исключение.

\subsubsection*{\#DB Отладка (Вектор 1)}
Подробно описано в \cite{amd_pm_v2}. Не возвращает код ошибки.

\subsubsection*{NMI Немаскируемое прерывание (Вектор 2)}
NMI возникает когда системное окружение сигнализирует процессору о наличии
немаскируемого прерывания. Не возвращает код ошибки.

\subsubsection*{\#BP Точка останова (Вектор 3)}
Возникает при выполнении инструкции INT3. Не может быть отключено. Не
возвращает код ошибки.

\subsubsection*{\#OF Переполнение (Вектор 4)}
Возникает в результате выполнения инструкции INTO если в RFLAGS установлен бит
переполнения (RFLAGS.OF=1). Не возвращает код ошибки.

\subsubsection*{\#BR Выход за границы (Вектор 5)}
Может возникнуть в результате выполнения инструкции BOUND. Инструкция BOUND
сравнивает индекс массива с верхней и нижней границей. Если индекс вышел за
границы - генерируется исключение. Не возвращает код ошибки.

\subsubsection*{\#UD Неверная операция (Вектор 6)}
Данное исключение возникает при попытке выполнить неправильную или
неопределенную операцию. Не возвращает код ошибки.

\subsubsection*{\#NM Устройство недоступно (Вектор 7)}
Не возвращает код ошибки.

\subsubsection*{\#DF Двойная ошибка (Вектор 8)}
Может возникнуть, когда второе исключение возникло, во время обработки
первого. Возвращает 0 в качесте кода ошибки.

\subsubsection*{\#TS Неверный TSS (Вектор 10)}
Возвращает код ошибки в формате селектора. Подробно описано в \cite[стр. 222]{amd_pm_v2}.

\subsubsection*{\#NP Отсутствует сегмент (Вектор 11)}
Возникает при попытке загрузить сегмент или шлюз у которого сброшен бит P.
Возвращает код ошибки в формате селектора.

\subsubsection*{\#SS Ошибка со стеком (Вектор 12)}
Возвращает код ошибки в формате селектора.

\subsubsection*{\#GP Нарушение защиты (Вектор 13)}
Возникает при нарушении защиты или неверном использовании функций AMD64.
Возвращает код ошибки в формате селектора.

\subsubsection*{\#PF Страничная ошибка (Вектор 14)}
Может возникнуть при доступе к памяти, в одной из следующих ситуаций:
\begin{enumerate}
\item Элемент таблицы страничного преобразования, задействованный в
преобразовании адреса, отсутствует в физической памяти.
\item Попытка процессора загрузить инструкцию из неисполняемой страницы.
\item При доступе к памяти была нарушена одна из проверок
(пользователь/супервизор, чтение/запись или обе).
\item Зарезервированный бит в одном из элементов таблицы страничного
преобразования установлен в 1.
\end{enumerate}

Процессор сохраняет виртуальный адрес, вызвавший страничное
исключение в регистре CR2. Формат кода ошибки показан на
рис.~\ref{fig:page_fault_error_code}.

\subsubsection*{\#MF Исключение с плавающей точкой (Вектор 16)}
Не возвращает код ошибки.

\subsubsection*{\#AC Ошибка выравнивания (Вектор 17)}
Данное исключение возникает при обращении к невыровненным данным, если
включена проверка выравнивания. Возвращает 0 в качестве кода ошибки.

\subsubsection*{\#MC Machine-check (Вектор 18)}
Не возвращает код ошибки.

\subsubsection*{\#XF SIMD исключение с плавающей точнкой (Вектор 19)}
Не возвращает код ошибки.

\subsubsection*{\#SX Исключение защиты (Вектор 30)}
Возвращает код ошибки.

\subsubsection*{Прерывания определнные пользователем (Вектора 32-255)}
Возникают в следующих случаях:
\begin{enumerate}
\item Процессору поступает сигнал о наличии внешнего прерывания.
\item Программное обеспечение выполняет инструкцию INTn, в которой n
определяет номер прерывания.
\end{enumerate}

Не возвращают код ошибки. Значение IP зависит от источника прерывания:
\begin{enumerate}
\item Внешние прерывания определяются на границах инструкций. Сохраненный IP
указывает на инструкцию, следующую сразу за границей, на которой было
обнаружено прерывание.
\item Если прерывание возникло в результате выполнения инструкции INTn,
сохраненный IP указывает на инструкцию, следующую за INTn.
\end{enumerate}

Внешние прерывания можно замаскировать, установив RFLAGS.IF=0. Программные
прерывания нельзя отключить.

\subsection{Коды ошибок}
При обработке некоторых исключений процессор использует коды ошибок. Код
ошибки помещается в стек перед вызовом обработчика исключения. Код ошибки
может быть в двух форматах: в формате селектора (для большинства исключений),
в формате страничного исключения.

\subsubsection*{Формат селектора}
На рис.~\ref{fig:selector_error_code} показан код ошибки в формате селектора.
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/selector-error-code}
  \caption{Код ошибки в формате селектора}
  \label{fig:selector_error_code}
\end{figure}

Код ошибки в формате селектора содержит следующую информацию:
\begin{enumerate}
\item EXT -- бит 0. Если этот бит установлен в 1, значит исключение вызвано
чем-то вне процессора. В противном случае - источник исключения находится в
процессоре.
\item IDT -- бит 1. Если этот бит установлен в 1, значит поле "индекс
селектора" ссылается на дескриптор шлюза, расположенный в IDT. В
противном случае - поле "индекс селектора" ссылается на дескриптор
расположенный либо в GDT, либо в LDT (определяется битом TI).
\item TI -- бит 2. Если этот бит установлен в 1, значит поле "индекс
селектора" ссылается на дескриптор, расположенный в LDT, в противном случае -
в GDT.
\item Индекс селектора -- биты 15:3. Определяет индекс в GDT, LDT или IDT.
\end{enumerate}

\subsubsection*{Формат при страничном исключении}
На рис.~\ref{fig:page_fault_error_code} показан код ошибки в формате страничного исключения.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/page-fault-error-code}
  \caption{Код ошибки при страничном исключении}
  \label{fig:page_fault_error_code}
\end{figure}

Код ошибки в данном формате содержит следующую информацию:
\begin{enumerate}
\item P -- бит 0. Если этот бит сбошен в 0, значит страничное исключение было
вызвано отсутсвием страницы. Инача - оно было вызвано нарушением одной из
страничных проверок.
\item R/W -- бит 1. Если этот бит сброшен в 0 -- исключение было сгенерировано
при попытке чтения из страницы. Иначе - исключение было сгенерировано при
попытке записи в страницу.
\item U/S -- бит 2. Если этот бит сброшен в 0 -- ошибка была вызвана при
доступе в режиме супервизора (CPL=0,1,2). В противном случае -- ошибка была
вызвана в режиме пользователя (CPL=3).
\item RSV -- бит 3. Если этот бит установлен в 1 -- ошибка была вызвана в
результате прочтения процессором единицы (1) из зарезервированного поля в
элементы таблицы страниц. Этот тип ошибки может возникнуть только если
CR4.PSE=1 или CR4.PAE=1.
\item I/D -- бит 3. Если этот бит установлен в 1 -- ошибка была сгенерирована
при попытки извлечения следующей инструкции. В противном случае этот бит
сброшен в 0. Этот бит определен только если включена функция запрета
исполнения (EFER.NXE=1 и CR4.PAE=1).
\end{enumerate}

\subsubsection*{Приоритеты}
Для возможности последовательной обработки одновременных прерываний,
прерываниям назначаются приоритеты. AMD64 разделяет прерывания на группы по
приоритетам, приоритеты внутри группы зависят от реализации.

При одновременном возникновении нескольких прерываний, процессор передает
управление обработчику прерывания с самым высоким приоритетом.
Низкоприоритетные внешние прерывания будут обработаны в порядке их приоритета,
после обработки прерываний с более высоким приоритетом. Низкоприоритетные
внутренние прерывания (исключения) отбрасываются. Они возникнут повторно,
когда обработчик прерывания завершится и вернет управление на прерванную
инструкцию. Программные прерывания так же отбрасываются, они будут повторно
возбуждены при перезапуске инструкции программного прерывания~\cite[стр. 232]{amd_pm_v2}.

\subsection{Обработа прерываний в <<длинном>> режиме}
\subsubsection*{Шлюзы прерываний и шлюзы ловушек}
В <<длинном>> режиме передача управления обработчику прерывания или исключения
осуществляется через дескрипторы шлюзов. В данном режиме IDT состоит из 256
16-байтных дескрипторов. Определеные 2 типа дескриптора:
\begin{enumerate}
\item Шлюз прерывания (interrupt)
\item Шлюз ловушки (trap)
\end{enumerate}

Отличие между ними в том, что при переходе через шлюз прерывания процессор
запрещает автоматически запрещает прерывания (сбрасывает RFLAGS.IF в 0).

\subsubsection*{Обработчики прерываний}
При возникновении прерывания процессор умножает номер прерывания на 16 и
использует результат в качестве смещения в IDT. Найденный дескриптор шлюза
содержит селектор сегмента и 64-битное смещение (виртуальный адрес обработчика
прерывания). Селектор сегмента указывает на дескриптор сегмента кода
расположенный в GDT или LDT. Дескриптор сегмента кода используется только для
проверки доступа и перевода процессора в <<длинный>> режим.

На рис.~\ref{fig:locating_interrupt_handler} показано как происходит поиск
обработчика прерывания в <<длинном>> режиме.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/locating-interrupt-handler}
  \caption{Определение положения обработчика прерывания в <<длинном>> режиме}
  \label{fig:locating_interrupt_handler}
\end{figure}


\subsubsection*{Стек обработчика прерывания}
В <<длинном>> режиме стек прерванной программы (SS:RSP) всегда заносится в
стек обработчика прерывания, независимо от того был ли изменен уровень
привелегий. Регистр SS не используется в 64-битном режиме, SS заносится для
обеспечения возможности возврата из обработчика прерывания в режиме
совместимости. Безусловное занесение в стек SS:RSP дает возможность
разработчикам операционных систем использовать одинаковые структуры данных для
всех прерываний.

В <<длинном>> режиме при вызове обработчика прерывания процессор выполняет
следующие действия~\cite{amd_pm_v2}:
\begin{enumerate}
\item Выравнивает стек обработчика прерывания (применяет к RSP маску 0xFFFF\_FFFF\_FFFF\_FFF0)
\item Если поле IST в дескрипторе шлюза прерывания не равно 0, заносит
	указатель стека из IST в RSP.
\item Если будет изменен уровень привилегий, уровень привелегий требуемого
	дескриптора (DPL) используется в качестве индекса в TSS для выбора
	нового указателя стека (RSP), в регистр SS заносится 0.
\item Заносит в новый стек предыдущие значения SS:RSP. Значение SS дополняется
	6ю байтами, чтобы быть выровненным по 8 байтной границе.
\item Заносит 64-битное значение RFLAGS в новый стек. Старшие 32 бита имеют
	значение 0.
\item Сбрасывает флаги TF, NT, RF в регистре флагов RFLAGS в 0.
\item Обрабатывает значение RFLAGS.IF в зависимости от типа шлюза прерывания:
	\begin{enumerate}
	\item Если дескриптор шлюза, является шлюзом прерывания -- RFLAGS.IF
		сбрасывается в 0.
	\item В противном случае - RFLAGS.IF остается без изменений
	\end{enumerate}
\item Заносит в стек CS:RIP прерванной программы. Значение CS дополняется 6ю
	байтами, чтобы быть выровненным по 8 байтной границе.
\item Если данное прерывание возвращает код ошибки -- процессор заносит этот
	код в стек. Код ошибки дополняется 4мя байтами, чтобы быть выровненным
	по 8 байтной границе.
\item Загружает селектор сегмента из дескриптора шлюза в регистр CS. Процессор
	проверяет что целевой сегмент кода является 64-битным сегментом кода.
\item Загружает смещение из дескриптора шлюза в RIP.
\end{enumerate}

На рис.~\ref{fig:interrupt_handler_stack} показано состояние стека после
передачи управления обработчику прерывания.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/interrupt-handler-stack}
  \caption{Стек обработчика прерывания без смены уровня привилегий}
  \label{fig:interrupt_handler_stack}
\end{figure}

В <<длинном>> режиме при переключении стека из-за смены уровня привилегий,
новое значение для SS выбирается не из TSS (как в защищенном режиме). В
<<длинном>> режиме из TSS берется только значение RSP, а в SS заносится ноль,
позволяя тем самым обрабатывать вложенные прерывания. В SS.RPL заносится
значение текущего уровня привилегий (CPL).

Стек обработчика прерывания при смене уровня привилегий, выглядит так же, как
стек обработчика прерывания без смены уровня привилегий, меняется только
регистр SS (в него заносится 0).

\subsubsection*{Таблица стеков обработчиков прерываний}
В <<длинном>> режиме введен новый механизм переключения стеков -- IST, который
можно использовать в качестве альтернативы описанному выше механизму.

При использование данного механизма стек переключается всегда. Данный механизм
можно использовать отдельно для разных векторов прерываний, испльзуя поле IST
в дескрипторах шлюзов (в IDT).

На рис.~\ref{fig:interrupt_handler_stack_ist} показано как используется данный
механизм. Если при возникновении прерывания поле IST не равно 0, процессор
использует значение IST в качестве индекса в TSS, загружая таким образом указатель стека
(RSP) для обработчика прерывания. Если изменяется текущий уровень привилегий
-- в регистр SS загружается 0 и в SS.RPL заносится значение нового уровня
привилегий. После того как стек загружен, процессор кладет в него предыдущий
указатель стека, флаги процессора (RFLAGS), адрес возврата и код ошибки (если
необходим). После этого управление передается обработчику прерывания. Если два
обработчика прерывания используют один и тот же стек и второе прерывание
возникнет во время обработки первого -- оно затрет стек первого прерывания.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/interrupt-handler-stack-ist}
  \caption{Переключение стека с использованием IST}
  \label{fig:interrupt_handler_stack_ist}
\end{figure}

\subsubsection*{Возврат из обработчика прерывания}
Для возврата в прерванную программу используется команда IRET. Механизм
обработки прерываний всегда использует 64-битный стек при сохранении значений
для обработчика прерываний и обработчик прерываний всегда выполняется в
64-битном режиме.

В <<длинном>> режиме, если при вызове обработчика прерывания произошла смена
уровня привилегий -- в SS будет загружен нулевой селектор. Если обработчик
прерывания будет прерван -- нулевой селектор будет сохранен в стеке, а в SS
будет повторно загружен другой нулевой селектор. Использование нулевого
селектора таким способом позволяет процессору правильно обрабатывать вложенные
вызовы и прерывания.

Обычно если IRET выталкивает из стека нулевой селектор в регистр SS приводит к
возникновения исключения <<сбой защиты>> (\#GP). Однако в <<длинном>> режиме,
нулевой селектор говорит о наличии вложенных обработчиков прерываний, поэтому
в <<длинном>> режиме инструкция IRET при определенных условиях (при переходе
на обработчик прерывания процессор остается в 64-битном режиме и переход
осуществляется на уровень привилегий меньше 3) может
выталкивать из стека нулевой селектор в SS и не вызывать сбой защиты.

\section{Переход в <<длинный>> режим}
\label{sec:long_mode_activation}

\section{APIC и IO APIC}
Межпроцессорные прерывания. Работа с IO APIC (как перенаправить внешние
прерывания, т.е. то, что раньше делали с использованием PIC'a).
