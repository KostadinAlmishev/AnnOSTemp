\chapter{Конструкторский раздел}
\label{cha:design}

\section{Режимы работы процессора}

\section{Виртуальная память}
\subsection{Системные дескрипторы}
\label{subsec:system_desriptor_format}

Сегментное преобразование + таблицы дескрипторов (в т.ч. формат IDT)

\section{Страничное преобразование}

\section{Сегмент состояния задачи (TSS)}
\subsection{Аппаратная многозадачность}
Задача (также называемая процессом) это программа, которую процессор может
исполнять, приостанавливать и позже продолжать исполнение с места последней
остановки. Пока задача приостановлена могут исполняться другие задачи. Каждая
задача имеет свой контекст, в который входят:
\begin{enumerate}
\item Сегмент кода и IP (указатель на следующую инструкцию)
\item Сегменты данных
\item Сегменты стека для всех уровней привилегий
\item Регистры общего назначения
\item Регистр флагов (rFLAGS)
\item Локальная таблица дескрипторов
\item Регистр задачи и указатель на предыдущую задачу
\item Битовые карты разрешений ввода/вывода и прерываний
\item Указатель на таблицу страничного преобразования верхнего уровня (CR3)
\end{enumerate}

В защищенном режиме работы процессора эта информация сохранялась в
сегменте состояния задачи (TSS) для возможности аппаратного переключения
задач~\cite[стр. 327]{amd_pm_v2}.

\subsection{Ресурсы управления задачами}
В <<длинном>> режиме аппаратное переключение задач не поддерживается, но
операционная система по прежнему должна инициализировать некоторые ресурсы
управления задачами:
\begin{enumerate}
\item Сегмент состояния задачи (TSS) -- сегмент, в котором хранится состояние
	процессора, связанное задачей.
\item Дескриптор TSS -- дескриптор сегмента, описывающий TSS.
\item Селектор TSS -- селектор сегмента, который ссылается на дескриптор TSS,
	расположенный в GDT.
\item Регистр задачи (TR) -- регистр, в котором хранится селектор и дескриптор
	TSS текущей задачи.
\end{enumerate}

На рис.~\ref{fig:task_management_resources} показано как связаны между собой
эти ресурсы в <<длинном>> режиме.
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/task-management-resources}
  \caption{Ресурсы управления задачами}
  \label{fig:task_management_resources}
\end{figure}

\subsubsection*{Селектор TSS}
Селекторы TSS это селекторы, которые указывают на дескрипторы TSS в GDT.
Формат селектора TSS совпадает с форматом других сегментных селекторов и
показан на рис.~\ref{fig:tss_selector}.

\begin{figure}
  \centering
  \includegraphics{inc/dia/tss-selector}
  \caption{Формат селектора TSS}
  \label{fig:tss_selector}
\end{figure}

Селектор состоит из следующих полей:
\begin{enumerate}
\item Индекс селектора. Биты 15:3. Определяет смещение дескриптора TSS в GDT.
\item Индикатор таблицы (TI). Бит 2. Данный бит должен быть сброшен в 0, это
	означает что селектор ссылается на запись в GDT. Дескрипторы TSS
	запрещено размещать в LDT и при попытки обратиться к дескриптору TSS,
	расположенному в LDT произойдет сбой защиты (\#GP).
\item Уровень привилегий (RPL). Биты 1:0. Равен уровню привилегий на котором
	находился процессор при загрузке селектора TSS в регистр задачи (TR).
\end{enumerate}

\subsubsection*{Дескриптор TSS}
Дескриптор TSS это системный дескриптор, который может быть расположен только
в GDT. Его формат описан ранее в \ref{subsec:system_desriptor_format}.

TSS должен иметь размер минимум 104 байта (т.е. минимальное значение поля <<предел>> -- 103).
Если размер TSS меньше -- при переключении задач будет сгенерировано
исключение <<неверный TSS (\#TS)>>.

\subsubsection*{Регистр задачи (TR)}
Регистр задачи хранит адрес TSS, определяет его размер и атрибуты. TR состоит
из двух частей -- видимой и теневой. В видимой (доступной для ПО) части хранится селектор TSS,
теневая часть содержит дескриптор TSS. При загрузке селектора TSS в TR
процессор автоматически загружает дескриптор TSS из GDT в теневую часть.
Загрузка нового значения в TR осуществляется инструкцией LTR. На
рис.~\ref{fig:task_register} показан формат TR в <<длинном>> режиме.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/task-register}
  \caption{Формат регистра задачи (TR)}
  \label{fig:task_register}
\end{figure}

\subsubsection*{Формат TSS}
Несмотря на то, что аппаратный механизм переключения задач не поддерживается в
<<длинном>> режиме, 64х-битный TSS должен быть объявлен. Системное ПО должно
создать как минимум один TSS для использования в <<длинном>> режиме и
выполнить инструкции LTR в 64х-битном режиме, чтобы загрузить в TR 64-х битный
TSS.

На рис.~\ref{fig:tss} показан формат TSS в <<длинном>> режиме. TSS включает
следующую информацию:
\begin{enumerate}
\item RSPn -- Байты 0x1B-0x04. 64-битные адреса указателей стека (RSP) для
	уровней привилегий 0,1 и 2.
\item ISTn -- Байты 0x5B-0x24. 64-битные адреса указателей стека, используемые
	при включенном механизме IST.
\item Базовый адрес битовой карты разрешений ввода/вывода. Байты 0x67-0x66.
\end{enumerate}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/tss}
  \caption{Формат TSS}
  \label{fig:tss}
\end{figure}



\section{Исключения и прерывания}

Исключения и прерывания приводят к передаче управления функциям операционной
системы. Эти функции называются обработчиками исключений и обработчиками
прерываний. Обычно прерывания обрабатываются незаметно для прерванной
программы. Во время передачи управления обработчику прерываний процессор
перестает выполнять прерванную программу и сохраняет адрес возврата.
Обработчик прерывания или исключения отвечает за сохранение контекста
прерванной программы. Это позволяет процессору продолжить исполнение
программы, после того как обработчик прерывания (исключения) завершится.

При возникновении прерывания или исключения процессор использует номер
прерывания как индекс в таблице дескрипторов прерываний (IDT). IDT
используется во всех режимах работы процессора, включая реальный режим (real
mode), защищенный режим (protected mode) и длинный режим (long mode).

Прерывания можно резделить на 3 категории~\cite{amd_pm_v2}: исключения,
программные прерывания и внешние прерывания.

Исключения (exceptions) возникают в результате ошибок во время исполнения ПО или внутренних
ошибок процессора. Исключения также могут возникать без наличия ошибочных
ситуаций, например при пошаговом выполнении программы. Исключения считаются
синхронными событиями, т.к. они возникаются в результате исполнения прерванной
инструкции.

Программные прерывания (software interrupts) возникаются в результате вызова прерывания (int). В
отличие от исключений и внешних прерываний, программные прерывания позволяют
намеренно вызывать обработчики прерываний. Как и исключения, программные
прерывания являются синхронными событиями.

Внешние прерывания (external interrupts) генерируются системой в результате возникновения ошибки
или какого-либо события вне процессора. Они доставляются на шину процессора
используя внешние сигналы. Внешние прерывания являются асинхронными событиями,
т.к. они возникают независимо от прерванной инструкции.

\subsection{Основные характеристики}
Исключения и прерывания имеют несколько различных характеристик, которые
зависят от того как они были доставлены и определяют как следует продолжить выполнение
прерванной программы.

\subsubsection*{Точность}
По отношению к прерванной инструкции прерывания делятся на:
\begin{itemize}
\item Точные прерывания возникают на предсказуемой границе. Эта граница
как правило -- первая инструкция, которая не была выполнена во время
возникновения прерывания. Все предыдущие инструкции были завершены перед
передачей управления обработчику прерывания. Указатель на граничную инструкцию
автоматически сохраняется процессором. Когда обработчик прерывания
завершается, он возвращается в прерванную программу и исполнение продолжается
с граничной инструкции.
\item Неточные. Не гарантируется возникновение на предсказуемой границе.
Границей может быть любая инструкция, которая не была завершена во время
возникновения прерывания. Неточные события можно считать асинхронными, т.к.
источник прерывания может быть не связан с исполняемой инструкцией.
Обработчики неточных прерываний и исключений обычно собирают информацию о
состоянии системы и передают специально программному обеспечению для
диагностики. Выполнение прерванной программы не продолжается.
\end{itemize}

\subsubsection*{Перезапуск инструкций}
Как было сказано выше, точные исключения возникают на границе инструкции. Эта
граница может находиться либо перед, либо после инструкции.

Для большинства исключений граничной является инструкция вызвавшая исключение,
т.е. граница устанавливается перед этой инструкцией. В этом случае все
инструкции предсшествующие данной (в програмном порядке) считаются
выполненными. Состояние программы не изменилось в процессе частичного
выполнения преванной инструкции.

Есть исключения для которых граничной является инструкция следующая за той,
которая вызвала исключение. В этом случае все предыдущие инструкции, включая
ту, которая вызывала исключение, считаются выполненными.

Состояние программы может быть изменено, когда граничной инструкцией является
инструкция, следующая за вызвавшей исключение. В частности такое может
произойти, когда исключение произошло в результате переключения задач. В этом
случае регистры общего назначения, сегментные регистры, CR3 и LDTR были обновлены
аппаратным мехазнимом переключения задач. Однако такое не может произойти в
"длинном режиме", т.к. в нем выключен механизм аппаратного переключения задач.

\subsubsection*{Типы исключений}
Исключения можно разделить на 3 типа в зависимости от того, являются ли они
точными и как они влияют на продолжение работы программы:
\begin{enumerate}
\item Ошибки (faults) -- являются точными исключениями возникающими на границе перед
инструкцией, вызвавшей исключение. Все изменения, вызванные данной инструкцией
отменются, поэтому инструкция может быть перезапущена.
\item Ловушки (traps) -- являются точными исключениями, возникающими на границе после
инструкции, вызвавшей исключение. Процессор полностью выполнил инструкцию,
вызвавшую исключение, т.о. все изменения, вызванные инструкцией сохранены.
rIP указывает на инструкцию, следующую за той, которая вызвала исключение.
\item Аварии (aborts) -- неточные инструкции, поэтому обычно они не позволяют
продолжить правильное выполнение программы.
\end{enumerate}

\subsubsection*{Маскирование внешних прерываний}
Программное обеспечение может маскировать некоторые прерывания и исключения.
Маскирование может задержать или не допустить запуск механизма обработки
прерываний при возникновении прерывания. Внешние прерывания можно разделить на
маскируемые и немаскируемые.

Маскируемые прерывания приводят к вызову обработчика прерывания только если
RFLAGS.IF=1. В противном случае они не доставляются до тех пор, пока RFLAGS.IF
не станет равные 0.

Немаскируемые прерывания (NMI) обрабатываются независимо от значения RFLAGS.IF.
Однако при возникновении NMI прерывания, последующие NMI прерывания будут
замаскированы до выполнения инструкции IRET.

\subsubsection*{Маскирование при переключение стека}
Процессор откладывает обработку маскируемых прерываний и отладочных исключений
при выполнении определенных последовательностей инструкций, которые обычно
используются программным обеспечением для переключения стека. Стандартная
последовательность, используемая при переключении стека выглядит следующим
образом:
\begin{enumerate}
\item Загруить селектор сегмента стека в регистр SS
\item Загрузить смещение начала стека в регистр ESP
\end{enumerate}

Если прерывание возникает после того, как загружен SS, но до загрузки ESP -
указатель стека прерванной программы будет неверным во время выполнения
обработчика прерывания.

Чтобы недопустить проблем с указателем стека, вызванных прерываниями,
процессор не обрабатывает внешние прерывания и отладночные исключения пока
инструкция следующая за MOV SS или POP SS не будет выполнена.

\subsubsection*{Отключение исключений}
Отключение исключений предотвращает обнаружение исключительных ситуаций, в
отличие от маскирования исключений, которое предотвращает запуск механизма
обработки исключительной ситауции после того, как она была обнаружена.
Некоторые исключения могут быть отключены системным программным обеспечением,
выполняющемся на нулевом уровне привилегий, используя биты в регистрах CR0 и
CR4.

Механизм отладочных исключений позволяет контролировать, когда определнные
точки останова включены и когда они выключены.

\subsection{Векторы прерываний}
Определенным исключениям и прерываниям назначены фиксированные номера (также
называемые векторами прерываний или просто векторами). Вектор прерывания
используется механизмом обработки прерываний для определения точки входа в
обработчик прерывания. Можно использовать до 256 векторов прерываний. Первые 32 вектора
зарезервированы для преопределенных прерываний и исключительных ситуаций.
Для программных прерываний можно использовать любые из свободных векторов.

В таблице~\ref{tab:interrupts} перечислены поддерживаемые номера прерываний, их названия,
мнемонические обозначения и краткое описание.

\begin{center}
    \begin{longtable}{|c|p{0.30\textwidth}|p{0.20\textwidth}|p{0.30\textwidth}|}
    \caption{Описание прерываний}
    \label{tab:interrupts}
    \\ \hline
    Вектор & Название & Мнемоническое обозначение & Причины возникновения \\
    \hline \endfirsthead
    \subcaption{Продолжение таблицы~\ref{tab:interrupts}}
    \\ \hline \endhead
    \hline \subcaption{Продолжение на след. стр.}
    \endfoot
    \hline \endlastfoot
    0   & Divide-by-Zero-Error & \#DE & Инструкции DIV, IDIV, AAM \\
    \hline
    1   & Debug & \#DB & Доступ к инструкциям и данным \\
    \hline
    2   & Non-Maskable-Interrupt & \#NMI & Внешний сигнал NMI \\
    \hline
    3   & Breakpoint & \#BP & Инструкция INT3 \\
    \hline
    4   & Overflow & \#OF & Инструкция INTO \\
    \hline
    5   & Bound-Range & \#BR & Инструкция BOUND \\
    \hline
    6   & Invalid-Opcode & \#UD & Неверные инструкции \\
    \hline
    7   & Device-Not-Available & \#NM & Инструкции x87 \\
    \hline
    8   & Double-Fault & \#DF & Исключение возникшее во время обработки
    другого исключения или прерывания \\
    \hline
    9   & Coprocessor Segment Overrun & --- & Не поддерживается
    (зарезервировано) \\
    \hline
    10  & Invalid-TSS & \#TS & Доступ к сементу состояния задачи (TSS) \\
    \hline
    11  & Segment-Not-Present & \#NP & Загрузка сегментного регистра \\
    \hline
    12  & Stack & \#SS & Загрузка SS и обращение к стеку \\
    \hline
    13  & General-Protection & \#GP & Доступ к памяти с различные проверки \\
    \hline
    14  & Page-Fault & \#PF & Доступ к памяти при включенном страничном
    преобразовании \\
    \hline
    15  & Зарезервировано & --- & --- \\
    \hline
    16  & x87 Floating-Point Exception-Pending & \#MF & Инструкции x87 \\
    \hline
    17  & Alignment-Check & \#AC & Доступ к памяти по невыровненным адресам \\
    \hline
    18  & Machine-Check & \#MC & Зависит от модели процессора \\
    \hline
    19  & SIMD Floating-Point & \#XF & SSE инструкции \\
    \hline
    20-29  & Зарезервировано & --- & --- \\
    \hline
    30  & Security Exception & \#SX & События связанныие с безопасностью \\
    \hline
    31  & Зарезервировано & --- & --- \\
    \hline
    0-255  & External Interrupts (Maskable) & \#INTR & Внешние прерывания \\
    \hline
    0-255  & Software Interrupts & --- & Инструкции INTn \\
    \hline
  \end{longtable}
\end{center}

В таблице~\ref{tab:interrupts_classification} приведена классификация векторов
прерываний.

\begin{center}
    \begin{longtable}{|c|p{0.30\textwidth}|c|c|}
    \caption{Классификация векторов прерываний}
    \label{tab:interrupts_classification}
    \\ \hline
    Вектор & Название & Тип & Точность \\
    \hline \endfirsthead
    \subcaption{Продолжение таблицы~\ref{tab:interrupts_classification}}
    \\ \hline \endhead
    \hline \subcaption{Продолжение на след. стр.}
    \endfoot
    \hline \endlastfoot
    0   & Divide-by-Zero-Error & Ошибка & Точное \\
    \hline
    1   & Debug & Ошибка или ловушка & Точное \\
    \hline
    2   & Non-Maskable-Interrupt & -- &  -- \\
    \hline
    3   & Breakpoint & Ловушка & Точное \\
    \hline
    4   & Overflow & Ловушка & Точное \\
    \hline
    5   & Bound-Range & Ошибка & Точное \\
    \hline
    6   & Invalid-Opcode & Ошибка & Точное \\
    \hline
    7   & Device-Not-Available & Ошибка & Точное \\
    \hline
    8   & Double-Fault & Авария & Не точное \\
    \hline
    9   & Coprocessor Segment Overrun & --- & --- \\
    \hline
    10  & Invalid-TSS & Ошибка & Точное \\
    \hline
    11  & Segment-Not-Present & Ошибка & Точное \\
    \hline
    12  & Stack & Ошибка & Точное \\
    \hline
    13  & General-Protection & Ошибка & Точное \\
    \hline
    14  & Page-Fault & Ошибка & Точное \\
    \hline
    15  & Зарезервировано & --- & --- \\
    \hline
    16  & x87 Floating-Point Exception-Pending & Ошибка & Не точное \\
    \hline
    17  & Alignment-Check & Ошибка & Точное \\
    \hline
    18  & Machine-Check & Авария & Не точное \\
    \hline
    19  & SIMD Floating-Point & Ошибка & Точное \\
    \hline
    20-29  & Зарезервировано & --- & --- \\
    \hline
    30  & Security Exception & --- & Точное \\
    \hline
    31  & Зарезервировано & --- & --- \\
    \hline
    0-255  & External Interrupts (Maskable) & --- & --- \\
    \hline
    0-255  & Software Interrupts & --- & --- \\
    \hline
  \end{longtable}
\end{center}

\subsubsection*{\#DE Деление на 0 (Вектор 0)}
Возникает когда делитель в инструкциях DIV и IDIV равен 0. Так же возникает,
когда не помещается в регистры назначения. Данное исключение не может быть
выключено.

Не возвращает код ошибки. Сохраненный IP указывает на инструкцию, вызвавшую
исключение.

\subsubsection*{\#DB Отладка (Вектор 1)}
Подробно описано в \cite{amd_pm_v2}. Не возвращает код ошибки.

\subsubsection*{NMI Немаскируемое прерывание (Вектор 2)}
NMI возникает когда системное окружение сигнализирует процессору о наличии
немаскируемого прерывания. Не возвращает код ошибки.

\subsubsection*{\#BP Точка останова (Вектор 3)}
Возникает при выполнении инструкции INT3. Не может быть отключено. Не
возвращает код ошибки.

\subsubsection*{\#OF Переполнение (Вектор 4)}
Возникает в результате выполнения инструкции INTO если в RFLAGS установлен бит
переполнения (RFLAGS.OF=1). Не возвращает код ошибки.

\subsubsection*{\#BR Выход за границы (Вектор 5)}
Может возникнуть в результате выполнения инструкции BOUND. Инструкция BOUND
сравнивает индекс массива с верхней и нижней границей. Если индекс вышел за
границы - генерируется исключение. Не возвращает код ошибки.

\subsubsection*{\#UD Неверная операция (Вектор 6)}
Данное исключение возникает при попытке выполнить неправильную или
неопределенную операцию. Не возвращает код ошибки.

\subsubsection*{\#NM Устройство недоступно (Вектор 7)}
Не возвращает код ошибки.

\subsubsection*{\#DF Двойная ошибка (Вектор 8)}
Может возникнуть, когда второе исключение возникло, во время обработки
первого. Возвращает 0 в качесте кода ошибки.

\subsubsection*{\#TS Неверный TSS (Вектор 10)}
Возвращает код ошибки в формате селектора. Подробно описано в \cite[стр. 222]{amd_pm_v2}.

\subsubsection*{\#NP Отсутствует сегмент (Вектор 11)}
Возникает при попытке загрузить сегмент или шлюз у которого сброшен бит P.
Возвращает код ошибки в формате селектора.

\subsubsection*{\#SS Ошибка со стеком (Вектор 12)}
Возвращает код ошибки в формате селектора.

\subsubsection*{\#GP Нарушение защиты (Вектор 13)}
Возникает при нарушении защиты или неверном использовании функций AMD64.
Возвращает код ошибки в формате селектора.

\subsubsection*{\#PF Страничная ошибка (Вектор 14)}
Может возникнуть при доступе к памяти, в одной из следующих ситуаций:
\begin{enumerate}
\item Элемент таблицы страничного преобразования, задействованный в
преобразовании адреса, отсутствует в физической памяти.
\item Попытка процессора загрузить инструкцию из неисполняемой страницы.
\item При доступе к памяти была нарушена одна из проверок
(пользователь/супервизор, чтение/запись или обе).
\item Зарезервированный бит в одном из элементов таблицы страничного
преобразования установлен в 1.
\end{enumerate}

Процессор сохраняет виртуальный адрес, вызвавший страничное
исключение в регистре CR2. Формат кода ошибки показан на
рис.~\ref{fig:page_fault_error_code}.

\subsubsection*{\#MF Исключение с плавающей точкой (Вектор 16)}
Не возвращает код ошибки.

\subsubsection*{\#AC Ошибка выравнивания (Вектор 17)}
Данное исключение возникает при обращении к невыровненным данным, если
включена проверка выравнивания. Возвращает 0 в качестве кода ошибки.

\subsubsection*{\#MC Machine-check (Вектор 18)}
Не возвращает код ошибки.

\subsubsection*{\#XF SIMD исключение с плавающей точнкой (Вектор 19)}
Не возвращает код ошибки.

\subsubsection*{\#SX Исключение защиты (Вектор 30)}
Возвращает код ошибки.

\subsubsection*{Прерывания определнные пользователем (Вектора 32-255)}
Возникают в следующих случаях:
\begin{enumerate}
\item Процессору поступает сигнал о наличии внешнего прерывания.
\item Программное обеспечение выполняет инструкцию INTn, в которой n
определяет номер прерывания.
\end{enumerate}

Не возвращают код ошибки. Значение IP зависит от источника прерывания:
\begin{enumerate}
\item Внешние прерывания определяются на границах инструкций. Сохраненный IP
указывает на инструкцию, следующую сразу за границей, на которой было
обнаружено прерывание.
\item Если прерывание возникло в результате выполнения инструкции INTn,
сохраненный IP указывает на инструкцию, следующую за INTn.
\end{enumerate}

Внешние прерывания можно замаскировать, установив RFLAGS.IF=0. Программные
прерывания нельзя отключить.

\subsection{Коды ошибок}
При обработке некоторых исключений процессор использует коды ошибок. Код
ошибки помещается в стек перед вызовом обработчика исключения. Код ошибки
может быть в двух форматах: в формате селектора (для большинства исключений),
в формате страничного исключения.

\subsubsection*{Формат селектора}
На рис.~\ref{fig:selector_error_code} показан код ошибки в формате селектора.
\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/selector-error-code}
  \caption{Код ошибки в формате селектора}
  \label{fig:selector_error_code}
\end{figure}

Код ошибки в формате селектора содержит следующую информацию:
\begin{enumerate}
\item EXT -- бит 0. Если этот бит установлен в 1, значит исключение вызвано
чем-то вне процессора. В противном случае - источник исключения находится в
процессоре.
\item IDT -- бит 1. Если этот бит установлен в 1, значит поле "индекс
селектора" ссылается на дескриптор шлюза, расположенный в IDT. В
противном случае - поле "индекс селектора" ссылается на дескриптор
расположенный либо в GDT, либо в LDT (определяется битом TI).
\item TI -- бит 2. Если этот бит установлен в 1, значит поле "индекс
селектора" ссылается на дескриптор, расположенный в LDT, в противном случае -
в GDT.
\item Индекс селектора -- биты 15:3. Определяет индекс в GDT, LDT или IDT.
\end{enumerate}

\subsubsection*{Формат при страничном исключении}
На рис.~\ref{fig:page_fault_error_code} показан код ошибки в формате страничного исключения.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/page-fault-error-code}
  \caption{Код ошибки при страничном исключении}
  \label{fig:page_fault_error_code}
\end{figure}

Код ошибки в данном формате содержит следующую информацию:
\begin{enumerate}
\item P -- бит 0. Если этот бит сбошен в 0, значит страничное исключение было
вызвано отсутсвием страницы. Инача - оно было вызвано нарушением одной из
страничных проверок.
\item R/W -- бит 1. Если этот бит сброшен в 0 -- исключение было сгенерировано
при попытке чтения из страницы. Иначе - исключение было сгенерировано при
попытке записи в страницу.
\item U/S -- бит 2. Если этот бит сброшен в 0 -- ошибка была вызвана при
доступе в режиме супервизора (CPL=0,1,2). В противном случае -- ошибка была
вызвана в режиме пользователя (CPL=3).
\item RSV -- бит 3. Если этот бит установлен в 1 -- ошибка была вызвана в
результате прочтения процессором единицы (1) из зарезервированного поля в
элементы таблицы страниц. Этот тип ошибки может возникнуть только если
CR4.PSE=1 или CR4.PAE=1.
\item I/D -- бит 3. Если этот бит установлен в 1 -- ошибка была сгенерирована
при попытки извлечения следующей инструкции. В противном случае этот бит
сброшен в 0. Этот бит определен только если включена функция запрета
исполнения (EFER.NXE=1 и CR4.PAE=1).
\end{enumerate}

\subsubsection*{Приоритеты}
Для возможности последовательной обработки одновременных прерываний,
прерываниям назначаются приоритеты. AMD64 разделяет прерывания на группы по
приоритетам, приоритеты внутри группы зависят от реализации.

При одновременном возникновении нескольких прерываний, процессор передает
управление обработчику прерывания с самым высоким приоритетом.
Низкоприоритетные внешние прерывания будут обработаны в порядке их приоритета,
после обработки прерываний с более высоким приоритетом. Низкоприоритетные
внутренние прерывания (исключения) отбрасываются. Они возникнут повторно,
когда обработчик прерывания завершится и вернет управление на прерванную
инструкцию. Программные прерывания так же отбрасываются, они будут повторно
возбуждены при перезапуске инструкции программного прерывания~\cite[стр. 232]{amd_pm_v2}.

\subsection{Обработа прерываний в <<длинном>> режиме}
\subsubsection*{Шлюзы прерываний и шлюзы ловушек}
В <<длинном>> режиме передача управления обработчику прерывания или исключения
осуществляется через дескрипторы шлюзов. В данном режиме IDT состоит из 256
16-байтных дескрипторов. Определеные 2 типа дескриптора:
\begin{enumerate}
\item Шлюз прерывания (interrupt)
\item Шлюз ловушки (trap)
\end{enumerate}

Отличие между ними в том, что при переходе через шлюз прерывания процессор
запрещает автоматически запрещает прерывания (сбрасывает RFLAGS.IF в 0).

\subsubsection*{Обработчики прерываний}
При возникновении прерывания процессор умножает номер прерывания на 16 и
использует результат в качестве смещения в IDT. Найденный дескриптор шлюза
содержит селектор сегмента и 64-битное смещение (виртуальный адрес обработчика
прерывания). Селектор сегмента указывает на дескриптор сегмента кода
расположенный в GDT или LDT. Дескриптор сегмента кода используется только для
проверки доступа и перевода процессора в <<длинный>> режим.

На рис.~\ref{fig:locating_interrupt_handler} показано как происходит поиск
обработчика прерывания в <<длинном>> режиме.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/locating-interrupt-handler}
  \caption{Определение положения обработчика прерывания в <<длинном>> режиме}
  \label{fig:locating_interrupt_handler}
\end{figure}


\subsubsection*{Стек обработчика прерывания}
В <<длинном>> режиме стек прерванной программы (SS:RSP) всегда заносится в
стек обработчика прерывания, независимо от того был ли изменен уровень
привелегий. Регистр SS не используется в 64-битном режиме, SS заносится для
обеспечения возможности возврата из обработчика прерывания в режиме
совместимости. Безусловное занесение в стек SS:RSP дает возможность
разработчикам операционных систем использовать одинаковые структуры данных для
всех прерываний.

В <<длинном>> режиме при вызове обработчика прерывания процессор выполняет
следующие действия~\cite{amd_pm_v2}:
\begin{enumerate}
\item Выравнивает стек обработчика прерывания (применяет к RSP маску 0xFFFF\_FFFF\_FFFF\_FFF0)
\item Если поле IST в дескрипторе шлюза прерывания не равно 0, заносит
	указатель стека из IST в RSP.
\item Если будет изменен уровень привилегий, уровень привелегий требуемого
	дескриптора (DPL) используется в качестве индекса в TSS для выбора
	нового указателя стека (RSP), в регистр SS заносится 0.
\item Заносит в новый стек предыдущие значения SS:RSP. Значение SS дополняется
	6ю байтами, чтобы быть выровненным по 8 байтной границе.
\item Заносит 64-битное значение RFLAGS в новый стек. Старшие 32 бита имеют
	значение 0.
\item Сбрасывает флаги TF, NT, RF в регистре флагов RFLAGS в 0.
\item Обрабатывает значение RFLAGS.IF в зависимости от типа шлюза прерывания:
	\begin{enumerate}
	\item Если дескриптор шлюза, является шлюзом прерывания -- RFLAGS.IF
		сбрасывается в 0.
	\item В противном случае - RFLAGS.IF остается без изменений
	\end{enumerate}
\item Заносит в стек CS:RIP прерванной программы. Значение CS дополняется 6ю
	байтами, чтобы быть выровненным по 8 байтной границе.
\item Если данное прерывание возвращает код ошибки -- процессор заносит этот
	код в стек. Код ошибки дополняется 4мя байтами, чтобы быть выровненным
	по 8 байтной границе.
\item Загружает селектор сегмента из дескриптора шлюза в регистр CS. Процессор
	проверяет что целевой сегмент кода является 64-битным сегментом кода.
\item Загружает смещение из дескриптора шлюза в RIP.
\end{enumerate}

На рис.~\ref{fig:interrupt_handler_stack} показано состояние стека после
передачи управления обработчику прерывания.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/interrupt-handler-stack}
  \caption{Стек обработчика прерывания без смены уровня привилегий}
  \label{fig:interrupt_handler_stack}
\end{figure}

В <<длинном>> режиме при переключении стека из-за смены уровня привилегий,
новое значение для SS выбирается не из TSS (как в защищенном режиме). В
<<длинном>> режиме из TSS берется только значение RSP, а в SS заносится ноль,
позволяя тем самым обрабатывать вложенные прерывания. В SS.RPL заносится
значение текущего уровня привилегий (CPL).

Стек обработчика прерывания при смене уровня привилегий, выглядит так же, как
стек обработчика прерывания без смены уровня привилегий, меняется только
регистр SS (в него заносится 0).

\subsubsection*{Таблица стеков обработчиков прерываний}
В <<длинном>> режиме введен новый механизм переключения стеков -- IST, который
можно использовать в качестве альтернативы описанному выше механизму.

При использование данного механизма стек переключается всегда. Данный механизм
можно использовать отдельно для разных векторов прерываний, испльзуя поле IST
в дескрипторах шлюзов (в IDT).

На рис.~\ref{fig:interrupt_handler_stack_ist} показано как используется данный
механизм. Если при возникновении прерывания поле IST не равно 0, процессор
использует значение IST в качестве индекса в TSS, загружая таким образом указатель стека
(RSP) для обработчика прерывания. Если изменяется текущий уровень привилегий
-- в регистр SS загружается 0 и в SS.RPL заносится значение нового уровня
привилегий. После того как стек загружен, процессор кладет в него предыдущий
указатель стека, флаги процессора (RFLAGS), адрес возврата и код ошибки (если
необходим). После этого управление передается обработчику прерывания. Если два
обработчика прерывания используют один и тот же стек и второе прерывание
возникнет во время обработки первого -- оно затрет стек первого прерывания.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{inc/dia/interrupt-handler-stack-ist}
  \caption{Переключение стека с использованием IST}
  \label{fig:interrupt_handler_stack_ist}
\end{figure}

\subsubsection*{Возврат из обработчика прерывания}
Для возврата в прерванную программу используется команда IRET. Механизм
обработки прерываний всегда использует 64-битный стек при сохранении значений
для обработчика прерываний и обработчик прерываний всегда выполняется в
64-битном режиме.

В <<длинном>> режиме, если при вызове обработчика прерывания произошла смена
уровня привилегий -- в SS будет загружен нулевой селектор. Если обработчик
прерывания будет прерван -- нулевой селектор будет сохранен в стеке, а в SS
будет повторно загружен другой нулевой селектор. Использование нулевого
селектора таким способом позволяет процессору правильно обрабатывать вложенные
вызовы и прерывания.

Обычно если IRET выталкивает из стека нулевой селектор в регистр SS приводит к
возникновения исключения <<сбой защиты>> (\#GP). Однако в <<длинном>> режиме,
нулевой селектор говорит о наличии вложенных обработчиков прерываний, поэтому
в <<длинном>> режиме инструкция IRET при определенных условиях (при переходе
на обработчик прерывания процессор остается в 64-битном режиме и переход
осуществляется на уровень привилегий меньше 3) может
выталкивать из стека нулевой селектор в SS и не вызывать сбой защиты.

\section{Переход в <<длинный>> режим}

\section{APIC и IO APIC}
Межпроцессорные прерывания. Работа с IO APIC (как перенаправить внешние
прерывания, т.е. то, что раньше делали с использованием PIC'a).
