\chapter{Конструкторский раздел}
\label{cha:design}

Для того чтобы иметь возможность получить доступ ко всем возможностям архитектуры AMD64
необходимо использовать 64-битную ОС, для работы которой необходимо перейти в 64-битный
подрежим длинного режима.

\section{Инициализация процессора и переход в длинный режим}
\label{sec:long_mode_activation}

\subsection{Инициализация реального режима}
Перед переходом в защищенный режим необходимо настроить базое окружение
реального режима (этим занимается BIOS). Это окружение включает:
\begin{itemize}
\item IDT реального режима, содержащую адреса точек входа в обработчики прерываний
	и исключений реального режима. После инициализации процессора базовый адрес IDT
	равен 0. При необходимости системное ПО может изменить его, загрузив новый адрес
	в регистр IDTR.
\item Обработчики прерываний и исключений реального режима. Должны быть загружены до
	включения внешних прерываний.
\item Указатель стека (SS:SP). Можно использовать значения SS:SP проинициализированные процессором.
\item Минимум один селектор сегмента данных для хранения структур данных защищенного режима,
	созданных в реальном режиме.
\end{itemize}

После того как выполнена инициализация реального режима, ПО может переходить к
инициализации защищенного режима.

\subsection{Инициализация защищенного режима}
Перед активацией длинного режима необходимо перейти в защищенный режим.
Для этого необходимо загрузить GDT, содержащую дескриптор сегмента кода и
дескриптор сегмента данных, доступный для чтения/записи.

После того, как новая GDT загружена, переход в защищенный режим можно выполнить установив CR0.PE в 1.

\subsection{Инициализация длинного режима}
В защищенном режиме системное ПО может подготовить структуры данных, необходимые для перехода в
длинный режим и сохранить их в произвольном месте в пределах первых 4х гигабайт физической памяти.
Эти структуры данных можно будет переместить за пределы 4х гигабайт после перехода в длинный режим.
Для перехода в длинный режим необходимы следующие структуры данных:
\begin{itemize}
\item 4 уровня таблиц страниц. Для перехода в длинный режим, также необходимо активировать PAE.
\item GDT, содержащая дескрипторы сегментов для ПО работающего в 64-битном режиме и в
	режиме совместимости, включающая:
	\begin{itemize}
	\item Дескриптор сегмента кода для длинного режима (должен быть установлен бит <<L>>).
	\item Дескриптор сегмента данных для ПО, работающего в режиме совместимости.
	\end{itemize}

	Существующая GDT защищенного режима может быть использована для хранения перечисленных
	выше дескрипторов.
\end{itemize}

\subsection{Активация и переход в длинный режим}
Для активации длинного режима необходимо установить бит EFER.LME в 1. Однако переход в длинный режим
не будет выполнен до активациии страничного преобразования. После того, как системное ПО
активирует страничное преобразование, при активированном длинном режиме, процессор перейдет в
длинный режим, установив при этом бит EFER.LMA в 1.

Для выбора подрежима работы процессора в длинном режиме используются 2 бита дескриптора сегмента кода (CS.L и CS.D).
Комбинация CS.L=1, CS.D=0 -- переводит процессор в 64-битный режим. Комбинация CS.L=0, CS.D=0 -- в
режим совместимости. Комбинация CS.L=1, CS.D=1 зарезервирована для будущего использования.

\subsubsection*{Переход в длинный режим}
Для перехода в защищенный режим, системное ПО должно выполнить следующие действия:
\begin{enumerate}[1.]
\item В любой последовательности:
	\begin{itemize}
	\item Активировать механизм расширения физических адресов, установив бит CR4.PAE в 1. Это
		необходимо сделать до активации страничного преобразования.
	\item Загрузить в регистр CR3 физический адрес PML4.
	\item Активировать длинный режим, установив бит EFER.LME в 1.
	\end{itemize}
\item Активировать страничное преобразование, установив бит CR0.PG в 1. В результате процессор установит бит EFER.LMA в 1.
\end{enumerate}

\subsubsection*{Обновление ссылок на таблицы системных дескрипторов}
После перехода в длинный режим регистр GDTR указывает ссылается на GDT унаследованного режима, которая расположена
в пределах первых 4-x гигабайт виртуального адресного пространства. Системемному ПО необходимо обновить GDTR, чтобы
он указывал на 64-битную версию GDT, используя команду LGDT.


\section{Организация памяти}
Как показано в главе~\ref{sec:page_translation}, в 64-битном режиме может использоваться
до 48 бит виртуального адреса (9 + 9 + 9 + 9 + 12), таким образом доступное адресное пространство
составляет 256~терабайт.

Как правило, ядро отображется в виртуальное адресного пространство каждого процесса (но при этом код ядра
остается доступным только для нулевого уровня привилегий), что позволяет снизить накладные расходы при
обращении к сервисам ядра.

Существует 2 основных способа расположения ядра в виртуальной памяти: в верхней части (англ. Higher Half Kernel)
и в нижней. Основными преимуществами расположения ядра в верхней части виртуального адресного пространства являются:
\begin{itemize}
\item Независимость приложений от размеров адресного пространства ядра (в случае расположения ядра в нижней части
	адресного пространства, при изменении размеров ядра может потребоваться перекомпиляция существующих
	прикладных программ).
\item 32-битные процессы могут использовать все 4~гигабайта адресного пространства.
\end{itemize}

На рис.~\ref{fig:vm-layout} показана схема организации виртуальной памяти ОС
(ядро расположено в верхней части виртуального адресного пространства).

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/vm-layout}
  \caption{Организация памяти ОС}
  \label{fig:vm-layout}
\end{figure}


\section{Загрузчик ОС}
Для запуска операционной системы необходимо настроить минимальное окружение (активировать линию A20,
загрузить GDT, перейти в защищенный режим), загрузить ос в память и передать ей управление.
Этим занимается загрузчик операционной системы (англ. bootloader). Существует множество загрузчиков
(GRUB, Lilo, Gujin, Bootf и др.), однако они не лучшим образом подходят для учебных целей, т.к. поддерживают
различное оборудование и файловые системы (что приводит к увеличению объемов и усложнению исходного кода),
поэтому было принято решение реализовать собственный загрузчик.

\subsection{Начальная загрузка компьютера}
Процесс начальной загрузки ОС в ЭВМ архитектуры x86 не претерпел
принципиальных изменений за тридцать лет, прошедших с момента появления
первых IBM PC до начала внедрения загрузки на основе интерфейса EFI вместо
BIOS. Загрузка системы начинается с того, что после включения компьютера
управление передается на реальный адрес 0xFFFF\_FFF0~\cite{amd_pm_v2}, где находится
ПЗУ с кодом BIOS~\cite{mstu_os_dev_method}.

После того, как BIOS проинициализирует устройства, вектора прерываний реального
режима и выберет загрузочный дисковод или жесткий диск, он загружает его
первый сектор (512~байт) по адресу 0x7c00, после чего передает управление на
него (реальный адрес 0000:7c00). Два последних байта сектора должны иметь
значения 0x55 и 0xAA, иначе BIOS не сочтет сектор загрузочным. Таким образом,
размер начальной части загрузчика ОС фактически не может превышать 510~байт.

Как было сказано выше, будет использоваться 64-битное ядро, расположенное в верхней части
виртуального адресного пространства, т.о. передать управление коду ядра можно будет
только после перехода в длинный режим (т.к. в унаследованном режиме доступно только 4~гигабайта
адресного пространства). Таким образом загрузчик должен выполнить следующие действия:
\begin{enumerate}[1.]
\item Открыть вентиль линии А20;
\item Определить доступные области физической памяти;
\item Загрузить ядро в физическую память;
\item Перейти в длинный режим;
\item Передать управление ядру;
\end{enumerate}

Чтобы вместить все эти действия в 510~байт, необходимо написать загрузчик полностью
на языке ассемблера с множеством <<магических>> констант, что приведет к сложному и
нечитаемому коду, который плохо подходит подходит для учебного процесса.

Поэтому было принято решение использовать 2 загрузчика, что позволит частично реализовать
их на языке Си (и соответственно улучшит читаемость кода).

\subsubsection*{Первый загрузчик}
Первый выполняет следующие действия: открытия вентиля линии А20, определение доступных
обалстей физической памяти, переход в защищенный режим, загрузка и передача управления
втором загрузчику.

\paragraph{Линия А20.} Для открытия вентиля линии А20 используется контроллер клавиатуры 8042.

\paragraph{Доступные области физической памяти.} На некоторые области физической памяти
отображены регистры аппаратного обеспечения. Информацией обо всех областях физической памяти
обладает BIOS. Для ее получения можно воспользоваться прерываниями BIOS, в частности -- int 0x15.

Загрузчик сохраняет эту информацию по адресу 0x7e00, чтобы второй загрузчик мог ей воспользоваться
(это может сделать только первый загрузчик, т.к. в защищенном режиме недоступны прерывания BIOS).

\paragraph{Переход в защищенный режим.} Для перехода в защищенный режим необходимо создать GDT,
содержащую как минимум 3 сегмента: нулевой сегмент, сегмент кода и сегмент данных. Данные сегменты
должны занимать все доступное адресное пространство (4~Гб), для этого необходимо чтобы поле
<<базовый адрес>> было равно 0, поле <<лимит>> было равно 0xfffff и были установлены биты
<<P>>, <<S>>, <<G>>, <<D>>, сегмент данных должен быть доступен для записи (бит <<W>>).

После создания GDT, нужно обновить регистр GDTR, для этого можно воспользовать командой LDGT.
При таком отображении виртуальные адреса совпадают с физическими.

Далее необходимо установить бит CR0.PE в 1. После этого процессор окажется в защищенном режиме,
однако сегментные регистры все ещё содержат дескрипторы сегментов реального режима, поэтому необходимо
обновить значения сегментных регистров, чтобы они содержали дескрипторы сегментов защищенного
режима. Селекторы сегментов данных можно обновить используя команду MOV, селектор сегмента кода
можно изменить командой LJMP.

После этого можно передать управление функции, написанной на языке Си.

\paragraph{Загрузка и передача управления втором загрузчику.} Чтение загрузчика с диска
осуществляется напрямую через порты контроллера IDE. Второй загрузчик расположен в фиксированной
области диска (начиная со первого сектора, если считать с 0), это позволяет прочитать его заголовок
(в формате ELF~\cite{elf}), который содержит информацию о секциях и адрес точки входа.

Первый загрузчик загружает второй загрузчик в физические адреса, указанные в файле. И передает
управление второму загрузчику (адрес точки входа содержится в заголовке).


\subsubsection*{Второй загрузчик}
Второй загрузчик подготавливает все необходимые ядру структуры данных, загружает ядро,
переходит в длинный режим и передает управление ядру.

\paragraph{Определение доступной памяти.} С помощью списка доступных участков физической
памяти, полученного первым загрузчиком необходимо определить максимальное значение адреса,
это и будет значением доступной физической памяти.

\paragraph{Загрузка ядра.} Ядро ОС, так же как и второй загрузчик, расположено в фиксированной
области диска (начиная с 2048 сектора). Для загрузки заголовка ядра (которое так же как и
загрузчик имеет формат ELF) необходимо использовать память, находящуюся за вторым загрузчиком,
для определения границы загрузчика в скрипт линковщика добавлен символ \texttt{end}.

При загрузке секций ядра необходимо вручную сбрасывать старшие 32~бита 64-битных виртуальных адресов,
чтобы ядро было загружено в первые 4~Гб физической памяти.

\paragraph{Подготовка стрктур данных.} После загрузки ядра, необходимо выделить память и проинициализировать
используемые структуры данных: GDT, PML4, массив дескрипторов страниц и структуру, для передачи
ядру всей необходимой информации (содержит адрес GDT, PML4, массива дескрипторов страниц и количество страниц).

При инициализации GDT нужно выделить память минимум под 6 дескрипторов сегментов:
нулевой, сегмент кода ядра и сегмент данных ядра длинного режима, сегмет кода
и сегмент данных прикладных программ длинного режима, TSS. При реализации многопроцессорной
обработки, необходимо выделить дополнительно по одному сегменту TSS для каждого процессора.

Дескрипторы сегментов кода должны содержать бит <<L>>, чтобы процессор переходил в длинный
режим при загрузке такого дескриптора.

\paragraph{Инициализация свободных страниц.} После того, как выделена память под все
необходимые структуры данных, необходимо проинициализировать список свободных страниц,
с учетом списка доступных участков, полученного превым загрузчиком и областей,
занятых ядром и вторым загрузчиком.

\paragraph{Отображения.} Перед переходом в длинный режим и передачей управления ядру ОС,
необходимо добавить в иерархию таблиц страниц отображения для стека ядра, регистрах APIC и IOAPIC,
конфигурации, необходимой для инициализации ядра.

Для возможности продолжения работы загрузчика после включения страничного преобразования,
необходимо добавить отображение для загрузчика.

После этого необходимо создать отображение $[KERNEL\_BASE, PHYS\_MEM) \textup{->} [0, PHYS\_MEM)$,
где $KERNEL\_BASE$ -- базовый виртуальный адрес ядра (младшие 32-бита адреса равны 0), $PHYS\_MEM$ --
объем доступной физической памяти. Данное отображение необходимо для <<правильного>> отображения
виртуальных адресов в физические, в которые ядро было загружено, а также для того, чтобы иметь
возможность преобразовывать виртуальный адрес в физический и наоборот программно (не используя
страничное преобразование).

\paragraph{Переход в длинный режим.} После отображения всех необходимых ядру данных,
загрузчик выполняет переход в длинный режим. Для этого он загружает в GDTR новую GDT,
активирует PAE (CR4.PAE=1), загружает в регистр CR3 адрес PML4, активирует длинный режим
(EFER.LME=1), активирует страничное преобразование (CR0.PG=1).

С этого момента процессор находится в подрежиме совместимости длинного режима.
Для перехода в 64-битный режим, необходимо обновить содержимое регистра CS (загрузить в
него дескриптор 64-битного сегмента кода). После этого можно передать управление ядру.

\section{Ядро ОС}

\subsection{Инициализация структур данных}
- инициализировать структуры данных ядра (ремапы, удаление ненужных мапингов)
- инициализация списка процессов
- инициализация глобального cpu

\subsection{Обработка прерываний}
- инициализация прерываний, тут очень много всего
- тут же про системные вызовы

\subsection{Процессы}
создание, контексты, переключение, и т.д.
сюда же потоки ядра

\subsection{Планировщик}
- запустить планировщика
- включить прерывания
