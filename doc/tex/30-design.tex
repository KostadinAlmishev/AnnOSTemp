\chapter{Конструкторский раздел}
\label{cha:design}

Для того чтобы иметь возможность получить доступ ко всем возможностям архитектуры AMD64
необходимо использовать 64-битную ОС, для работы которой необходимо перейти в 64-битный
подрежим длинного режима.

% FIXME
Так как одним из основных требований к разрабатываемой операционной системе
является простота -- было решено использовать монолитное ядро, т.к. в этом
случае ядро будет представлять собой одну программу (загрузчик должен
будет загрузить только один файл; все сервисы находятся в одном адресном
пространстве). Разрабатывая ОС будет иметь монолитное ядро и собственный
загрузчик. Для запуска ОС будут использоваться эмуляторы Bochs и QEMU.



\section{Инициализация процессора и переход в длинный режим}
\label{sec:long_mode_activation}

\subsection{Инициализация реального режима}
Перед переходом в защищенный режим необходимо настроить базое окружение
реального режима (этим занимается BIOS). Это окружение включает:
\begin{itemize}
\item IDT реального режима, содержащую адреса точек входа в обработчики прерываний
	и исключений реального режима. После инициализации процессора базовый адрес IDT
	равен 0. При необходимости системное ПО может изменить его, загрузив новый адрес
	в регистр IDTR.
\item Обработчики прерываний и исключений реального режима. Должны быть загружены до
	включения внешних прерываний.
\item Указатель стека (SS:SP). Можно использовать значения SS:SP проинициализированные процессором.
\item Минимум один селектор сегмента данных для хранения структур данных защищенного режима,
	созданных в реальном режиме.
\end{itemize}

После того как выполнена инициализация реального режима, ПО может переходить к
инициализации защищенного режима.

\subsection{Инициализация защищенного режима}
Перед активацией длинного режима необходимо перейти в защищенный режим.
Для этого необходимо загрузить GDT, содержащую дескриптор сегмента кода и
дескриптор сегмента данных, доступный для чтения/записи.

После того, как новая GDT загружена, переход в защищенный режим можно выполнить установив CR0.PE в 1.

\subsection{Инициализация длинного режима}
В защищенном режиме системное ПО может подготовить структуры данных, необходимые для перехода в
длинный режим и сохранить их в произвольном месте в пределах первых 4х гигабайт физической памяти.
Эти структуры данных можно будет переместить за пределы 4х гигабайт после перехода в длинный режим.
Для перехода в длинный режим необходимы следующие структуры данных:
\begin{itemize}
\item 4 уровня таблиц страниц. Для перехода в длинный режим, также необходимо активировать PAE.
\item GDT, содержащая дескрипторы сегментов для ПО работающего в 64-битном режиме и в
	режиме совместимости, включающая:
	\begin{itemize}
	\item Дескриптор сегмента кода для длинного режима (должен быть установлен бит <<L>>).
	\item Дескриптор сегмента данных для ПО, работающего в режиме совместимости.
	\end{itemize}

	Существующая GDT защищенного режима может быть использована для хранения перечисленных
	выше дескрипторов.
\end{itemize}

\subsection{Активация и переход в длинный режим}
Для активации длинного режима необходимо установить бит EFER.LME в 1. Однако переход в длинный режим
не будет выполнен до активациии страничного преобразования. После того, как системное ПО
активирует страничное преобразование, при активированном длинном режиме, процессор перейдет в
длинный режим, установив при этом бит EFER.LMA в 1.

Для выбора подрежима работы процессора в длинном режиме используются 2 бита дескриптора сегмента кода (CS.L и CS.D).
Комбинация CS.L=1, CS.D=0 -- переводит процессор в 64-битный режим. Комбинация CS.L=0, CS.D=0 -- в
режим совместимости. Комбинация CS.L=1, CS.D=1 зарезервирована для будущего использования.

\subsubsection*{Переход в длинный режим}
Для перехода в защищенный режим, системное ПО должно выполнить следующие действия:
\begin{enumerate}[1.]
\item В любой последовательности:
	\begin{itemize}
	\item Активировать механизм расширения физических адресов, установив бит CR4.PAE в 1. Это
		необходимо сделать до активации страничного преобразования.
	\item Загрузить в регистр CR3 физический адрес PML4.
	\item Активировать длинный режим, установив бит EFER.LME в 1.
	\end{itemize}
\item Активировать страничное преобразование, установив бит CR0.PG в 1. В результате процессор установит бит EFER.LMA в 1.
\end{enumerate}

\subsubsection*{Обновление ссылок на таблицы системных дескрипторов}
После перехода в длинный режим регистр GDTR ссылается на GDT унаследованного режима, которая расположена
в пределах первых 4-x гигабайт виртуального адресного пространства. Системемному ПО необходимо обновить GDTR,
чтобы он указывал на 64-битную GDT, используя команду LGDT.


\section{Организация памяти}
Как было сказано в главе~\ref{sec:page_translation}, в 64-битном режиме может использоваться
до 48 бит виртуального адреса (9 + 9 + 9 + 9 + 12), таким образом доступное адресное пространство
составляет 256~терабайт.

Как правило, ядро отображется в виртуальное адресного пространство каждого процесса (но при этом код ядра
остается доступным только для нулевого уровня привилегий), что позволяет снизить накладные расходы при
обращении к сервисам ядра.

Существует 2 основных способа расположения ядра в виртуальной памяти: в верхней части (англ. Higher Half Kernel)
и в нижней. Основными преимуществами расположения ядра в верхней части виртуального адресного пространства являются:
\begin{itemize}
\item Независимость приложений от размеров адресного пространства ядра (в случае расположения ядра в нижней части
	адресного пространства, при изменении размеров ядра может потребоваться перекомпиляция существующих
	прикладных программ).
\item 32-битные процессы могут использовать все 4~гигабайта адресного пространства.
\end{itemize}

На рис.~\ref{fig:vm-layout} показана схема организации виртуальной памяти ОС
(ядро расположено в верхней части виртуального адресного пространства).

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/vm-layout}
  \caption{Организация памяти ОС}
  \label{fig:vm-layout}
\end{figure}


\section{Загрузчик ОС}
Для запуска операционной системы необходимо настроить минимальное окружение (активировать линию A20,
загрузить GDT, перейти в защищенный режим), загрузить ос в память и передать ей управление.
Этим занимается загрузчик операционной системы (англ. bootloader). Существует множество загрузчиков
(GRUB, Lilo, Gujin, Bootf и др.), однако они не лучшим образом подходят для учебных целей, т.к. поддерживают
различное оборудование и файловые системы (что приводит к увеличению объемов и усложнению исходного кода),
поэтому было принято решение реализовать собственный загрузчик.

\subsection{Начальная загрузка компьютера}
Процесс начальной загрузки ОС в ЭВМ архитектуры x86 не претерпел
принципиальных изменений за тридцать лет, прошедших с момента появления
первых IBM PC до начала внедрения загрузки на основе интерфейса EFI вместо
BIOS. Загрузка системы начинается с того, что после включения компьютера
управление передается на реальный адрес 0xFFFF\_FFF0~\cite{amd_pm_v2}, где находится
ПЗУ с кодом BIOS~\cite{mstu_os_dev_method}.

После того, как BIOS проинициализирует устройства, вектора прерываний реального
режима и выберет загрузочный дисковод или жесткий диск, он загружает его
первый сектор (512~байт) по адресу 0x7c00, после чего передает управление на
него (реальный адрес 0000:7c00). Два последних байта сектора должны иметь
значения 0x55 и 0xAA, иначе BIOS не сочтет сектор загрузочным. Таким образом,
размер начальной части загрузчика ОС фактически не может превышать 510~байт.

Как было сказано выше, будет использоваться 64-битное ядро, расположенное в верхней части
виртуального адресного пространства, т.о. передать управление коду ядра можно будет
только после перехода в длинный режим (т.к. в унаследованном режиме доступно только 4~гигабайта
адресного пространства). Таким образом загрузчик должен выполнить следующие действия:
\begin{enumerate}[1.]
\item Открыть вентиль линии А20;
\item Определить доступные области физической памяти;
\item Загрузить ядро в физическую память;
\item Перейти в длинный режим;
\item Передать управление ядру;
\end{enumerate}

Чтобы вместить все эти действия в 510~байт, необходимо написать загрузчик полностью
на языке ассемблера с множеством <<магических>> констант, что приведет к сложному и
нечитаемому коду, который плохо подходит подходит для учебного процесса.

Поэтому было принято решение использовать 2 загрузчика, что позволит частично реализовать
их на языке Си (и соответственно улучшит читаемость кода).

\subsubsection*{Первый загрузчик}
Первый загрузчик выполняет следующие действия: открытие вентиля линии А20, определение доступных
обалстей физической памяти, переход в защищенный режим, загрузка и передача управления
втором загрузчику.

\paragraph{Линия А20.} Для открытия вентиля линии А20 используется контроллер клавиатуры 8042.

\paragraph{Доступные области физической памяти.} На некоторые области физической памяти
отображены регистры аппаратного обеспечения, поэтому их нельзя использовать для размещения
данных пользователя и операционной системы. Информацией обо всех областях физической памяти
обладает BIOS. Для ее получения можно воспользоваться прерываниями BIOS, в частности -- int 0x15.

Загрузчик сохраняет эту информацию по адресу 0x7e00, чтобы второй загрузчик мог ей воспользоваться
(это может сделать только первый загрузчик, т.к. в защищенном режиме недоступны прерывания BIOS).

\paragraph{Переход в защищенный режим.} Для перехода в защищенный режим необходимо создать GDT,
содержащую как минимум 3 сегмента: нулевой сегмент, сегмент кода и сегмент данных. Данные сегменты
должны занимать все доступное адресное пространство (4~Гб), для этого необходимо чтобы поле
<<базовый адрес>> было равно 0, поле <<лимит>> было равно 0xfffff и были установлены биты
<<P>>, <<S>>, <<G>>, <<D>>, сегмент данных должен быть доступен для записи (бит <<W>>).

После создания GDT, нужно обновить регистр GDTR, для этого можно воспользовать командой LDGT.
При таком отображении виртуальные адреса совпадают с физическими.

Далее необходимо установить бит CR0.PE в 1. После этого процессор окажется в защищенном режиме,
однако сегментные регистры все ещё содержат дескрипторы сегментов реального режима, поэтому необходимо
обновить значения сегментных регистров, чтобы они содержали дескрипторы сегментов защищенного
режима. Селекторы сегментов данных можно обновить используя команду MOV, селектор сегмента кода
можно изменить командой LJMP.

\paragraph{Загрузка и передача управления втором загрузчику.} Чтение загрузчика с диска
осуществляется напрямую через порты контроллера IDE. Второй загрузчик расположен в фиксированной
области диска (начиная с первого сектора, если считать с 0), это позволяет прочитать его заголовок
(в формате ELF~\cite{elf}), который содержит информацию о секциях и адрес точки входа.

Первый загрузчик загружает второй загрузчик в физические адреса, указанные в файле. И передает
управление второму загрузчику (адрес точки входа содержится в заголовке).


\subsubsection*{Второй загрузчик}
Второй загрузчик подготавливает все необходимые ядру структуры данных, загружает ядро,
переходит в длинный режим и передает управление ядру.

\paragraph{Определение доступной памяти.} С помощью списка доступных участков физической
памяти, полученного первым загрузчиком необходимо определить максимальное значение адреса,
это и будет значением доступной физической памяти.

\paragraph{Загрузка ядра.} Ядро ОС, так же как и второй загрузчик, расположено в фиксированной
области диска (начиная с 2048 сектора). Для загрузки заголовка ядра (которое так же как и
загрузчик имеет формат ELF) необходимо использовать память, находящуюся за вторым загрузчиком.
Для определения границы загрузчика в скрипт линковщика добавлен символ \texttt{end}.

При загрузке секций ядра необходимо сбрасывать старшие 32~бита 64-битных виртуальных адресов,
чтобы ядро было загружено в первые 4~Гб физической памяти.

\paragraph{Подготовка стрктур данных.} После загрузки ядра, необходимо выделить память и проинициализировать
используемые структуры данных: GDT, PML4, массив дескрипторов страниц и структуру, для передачи
ядру всей необходимой информации (содержит адрес GDT, PML4, массива дескрипторов страниц и количество страниц).

При инициализации GDT нужно выделить память минимум под 6 дескрипторов сегментов:
нулевой, сегмент кода ядра и сегмент данных ядра длинного режима, сегмет кода
и сегмент данных прикладных программ длинного режима, TSS. При реализации многопроцессорной
обработки, необходимо выделить дополнительно по одному сегменту TSS для каждого процессора.

Дескрипторы сегментов кода должны содержать бит <<L>>, чтобы процессор переходил в длинный
режим при их загрузке.

\paragraph{Инициализация свободных страниц.} После того, как выделена память под все
необходимые структуры данных, необходимо проинициализировать список свободных страниц,
с учетом списка доступных участков, полученного превым загрузчиком и областей,
занятых ядром и вторым загрузчиком.

\paragraph{Отображения.} Перед переходом в длинный режим и передачей управления ядру ОС,
необходимо добавить в иерархию таблиц страниц отображения для стека ядра, регистров APIC и IOAPIC,
конфигурации, необходимой для инициализации ядра.

Для возможности продолжения работы загрузчика после включения страничного преобразования,
необходимо добавить отображение, сохраняющее адреса загрузчика: $[0, LOADER\_LEN) -> [0, LOADER\_LEN)$,
где $LOADER\_LEN$ -- размер памяти, занимаемой загрузчиком и созданными структурами данных.

После этого необходимо создать отображение $[KERNEL\_BASE, PHYS\_MEM) \textup{->} [0, PHYS\_MEM)$,
где $KERNEL\_BASE$ -- базовый виртуальный адрес ядра (младшие 32-бита адреса равны 0), $PHYS\_MEM$ --
объем доступной физической памяти. Данное отображение необходимо для <<правильного>> отображения
виртуальных адресов в физические, в которые ядро было загружено, а также для того, чтобы иметь
возможность преобразовывать виртуальный адрес в физический и наоборот программно (не используя
страничное преобразование).

\paragraph{Переход в длинный режим.} После отображения всех необходимых ядру данных,
загрузчик выполняет переход в длинный режим. Для этого он загружает в GDTR новую GDT,
активирует PAE (CR4.PAE=1), загружает в регистр CR3 адрес PML4, активирует длинный режим
(EFER.LME=1), активирует страничное преобразование (CR0.PG=1).

С этого момента процессор находится в подрежиме совместимости длинного режима.
Для перехода в 64-битный режим, необходимо обновить содержимое регистра CS (загрузить в
него дескриптор 64-битного сегмента кода). После этого можно передать управление ядру.

\section{Ядро ОС}

\subsection{Вывод на экран}
Вывод на экран осуществляется путем прямого доступа к видеопамяти (0xb8000). Один элемент
видеопамяти имеет размер 2 байта. Один байт определяет значение выводимого на экран символа,
второй -- его атрибуты. Видеопамять состоит из 25 строк, по 80 элементов в каждой.

Одна строка видеопамяти используется для ввода команд.

\subsection{Инициализация структур данных}
Для работы ядра необходимы структуры данных, подготовленные вторым загрзучиком:
адрес GDT, PML4 и массив дескрипторов страниц.

Переданные загрузчиком адреса находятся в виртуальном адресном пространстве загрузчика
и совпадают с физическими (за счет использования загрузчиком плоской модели памяти).

Для их преобразования в корректные адреса в виртуальном адресном пространстве ядра
достаточно прибавить к ним значение $KERNEL\_BASE$ (благодаря наличию отображения,
выполненного загрузчиком).

После этого необходимо обновить GDTR, т.к. он содержит виртуальный адрес GDT в адресном
пространстве загрузчика (совпадает с физическим адресом). После чего ядро может удалить
неиспользуемые отображения.

\subsection{Процессы}
Как было сказано в главе~\ref{sec:task_state}, каждый процесс имеет контекст, который позволяет
приостанавливать его выполнение и позже продолжать его. Контекст процесса показан
на рис.~\ref{fig:process-context}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth]{inc/dia/process-context}
  \caption{Контекст процесса}
  \label{fig:process-context}
\end{figure}

Каждый процесс имеет дескриптор, который включает: контекст процесса, имя и идентификатор процесса,
текущее состояние, виртуальный и физический адрес PML4.

В разрабатываемой ОС процессы могут находится в одном из четырех состояний:
\begin{enumerate}[1.]
\item \texttt{FREE} -- означает, что дескриптор свободен и может быть использован
	для создания нового процесса.
\item \texttt{READY} -- процесс готов к запуску, планировщик запустит этот процесс,
	когда до него дойдет очередь.
\item \texttt{RUN} -- процесс выполняется в данный момент на одном из процессоров.
\item \texttt{DONT\_RUN} -- ОС выполняет со структурой процесса какие-то критичные действия
	(например создание или уничтожение), поэтому процесс нельзя запускать.
\end{enumerate}

На рис.~\ref{fig:process-state-diagramm} представлена диаграмма состояний процесса.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.5\textwidth]{inc/dia/process-state-diagramm}
  \caption{Диаграмма состояний процесса}
  \label{fig:process-state-diagramm}
\end{figure}


Дескрипторы процессов хранится в глобальном массиве, поэтому ОС позволяет запускать
фиксированное число процессов. Данное решение имеет одно важное следствие: память
для всех критичных структур данных ядра выделена ещё на этапе загрузки ядра, это
означает, что страничное преобразование общей для всех процессов области ядра не
меняется в ходе работы ОС, что избавляет от необходимости его синхронизации
между разными процессами.

Разрабатываемая ОС не поддерживает приоритеты процессов, планирование осуществляется
по алгоритму Round Robin~\cite{tanenbaum}.

Вытеснение процессов происходит при возникновении прерывания по таймеру или посредством
системного вызова.

\paragraph{Прикладные программы.} Так как ядро не имеет файловой системы, прикладные
программы с помощью линковщика добавляются в образ ядра, при этом линковщик добаляет
символы вида \texttt{\_binary\_<файл>\_start}, \texttt{\_binary\_<файл>\_end} и
\texttt{\_binary\_<файл>\_size}. Ядро использует эти символы при создании прикладных процессов.

Каждый процесс имеет отдельное адресное пространство, для этого каждому процессу выделяется
отдельная PML4, в которую копируется область, отвечающая за страничное преобразовани адресного
пространства ядра, т.о. доступ к адресному пространству ядра можно получить из любого процесса
(при наличии прав).

Прикладные программы, так же как и ядро, имеют формат ELF. При создании процесса
ядро загружает необходимые секции, используя подготовленные линковщиком символы, в адресное
пространство нового процесса. После этого ядро выделяет память под стек процесса и отображает
ее в адресное пространство нового процесса.

Для того, чтобы планировщик запустил процесс, когда до него дойдет очередь, ядро
меняет статус нового процесса на \texttt{READY}.

\paragraph{Потоки ядра.} Ядро позволяет использовать потоки уровня ядра.
Они представляют собой процессы, выполняющиеся в адресном пространстве ядра.
Реализация потоков ядра будет рассмотрена в разделе~\ref{cha:impl}.

\subsection{Прерывания}
Как было сказано в главе~\ref{sec:exceptions_and_interrupts}, для обработки прерываний
и исключений используется IDT. Ядру необходимо создать обработчики прерываний и исключений,
и загрузить IDT, содержащую ссылки на эти обработчики.

Для описания обработчиков прерываний и исключений используются шлюзы дескрипторов прерываний,
т.к. это позволяет исключить гонки (англ. Race Condition) при обращении ядра и обработчика
прерывания к одним и тем же структурам данных.

Обработчики аппаратных прерываний используют механизм IST для переключения стека, это позволяет
разрешить прерывания в потоках ядра (в противном случае обработка прерывания может вызвать
переполнение стека потока ядра).

Ядру необходимо инициализировать TSS для каждого ядра, выделить память под стеки обработчиков
прерываний и исключений. После чего загрузить в регистр TR каждого процессора дескриптор TSS,
предназначенный для этого процессора.

Перед разрешением прерываний необходимо инициализировать APIC и настроить IOAPIC. Для этого
необходимо установить бит <<AE>> в регистре базового адреса APIC (глава~\ref{sec:apic_ioapic}).

\paragraph{Настройка IOAPIC.} Перед настройкой IOAPIC, ОС должна отключить PIC (замаскировать его прерывания),
чтобы избежать конфликтов~\cite{os_dev}. ОС сохраняет в регистрах IOREDTBL информацию о перенаправлении
прерываний: прерываний от таймера (0), будут доставляться в локальный APIC с номером 32, а прерывания от
клавиатуры (1) -- с номером 33. Это необходимо чтобы иметь возможность отличать стандартные исключения и
прерывания от прерываний от аппаратного обеспечения.

\paragraph{Настройка таймера.} Для инициализации таймера, как сказано в главе~\ref{sec:apic_ioapic},
необходимо в регистр ICR занести начальное значение таймера, в регистр DCR -- значение, на которое
будет уменьшаться значение CCR при каждом тике таймера, а в регистр Timer LVT занести номер вектора прерывания и
установить бит <<TM>>, чтобы таймер повторно инициализировался после срабатывания.

\paragraph{Обработка прерываний и исключений.} Как было сказано в главе~\ref{sec:exceptions_and_interrupts},
для некоторых прерываний процессор добавляет на стек код ошибки. Поэтому, чтобы сделать возможность единообразной
обработки прерываний и исключений, необходимо чтобы обработчики прерываний, для которых процессор не сохраняет в стеке
код ошибки, сохраняли в стеке дополнительные 8 байт. Это позволит использовать одну структуру данных для всех типов прерываний.

Каждый обработчик прерывания должен сохранить в стеке номер прерывания, чтобы обработчик верхнего уровня
мог определить какое прерывание произошло. Обработчик прерывания должен сохранить контекст прерванного
процесса, для возможности последующего корректного продолжения работы последнего после завершения обработки
прерывания.

Возврат из прерывания происходит так же, как и запуск процесса (с использованием контекста процесса,
сохраненного обработчиком прерывания).

\subsection{Системные вызовы}
ОС поддерживает следующие системные вызовы:
\begin{enumerate}[1.]
\item \texttt{PUTS} -- выводит на экран строку, переданную в качестве аргумента.
\item \texttt{EXIT} -- уничтожает процесс и освобождает занятые им ресурсы.
\item \texttt{YIELD} -- вызывает планировщик, который выбирает следующий процесс и запускает его.
\item \texttt{FORK} -- создает копию процесса, в качестве возвращаемого значения родительский
	процесс получает идентификатор дочернего процесса, а дочерний -- 0. Для избежания лишнего
	копирования используется механизм копирования при записи (англ. Copy On Write).
\end{enumerate}
