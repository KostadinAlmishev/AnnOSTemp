\chapter{Технологический раздел}
\label{cha:impl}

\section{Средства разработки}
При разработке операционных систем традиционно используется язык Си по ряду причин:
\begin{itemize}
\item возможность прямого доступа к памяти, манипуляций битовыми
структурами, свободное приведение типов;
\item возможность сборки программ без подключения стандартной
библиотеки;
\item совпадение имён в программе и в объектном файле (отсутствие декорирования имён,
	которое используется, например, компилятором языка C++);
\item отсутствие механизма обработки исключений и сборки мусора
\item возможность создания вставок на машинном языке;
\end{itemize}

Часть операционной системы не может быть реализована на языке C, поскольку
требует явного использования машинных команд, предназначенных для поддержки
реализации операционной системы. Такие части реализуются на языке ассемблера
-- в виде отдельных модулей или в виде ассемблерных вставок в функции на
языке C.

\section{Тестовое окружение}
Разработка операционной системы является практически бесполезным упражнением,
если нет возможности запустить ее и проверить работу только что внесенных
изменений. Существует два основных способа запуска ОС: на реальной машине
и на виртуальной машине.

К достоинствам использования виртуальной машины можно отнести: возможность
запуска ОС сразу после компиляции и возможность использования отладчика. Кроме
того, некоторые виртуальные машины выводят отладочную информацию, которая
может быть полезна при отладке. Основной недостаток использования виртуальных
машин заключается в том, что они поддерживают ограниченный набор устройст и
могут содержать ошибки.

Основным достоинством тестирования на реальной машине является то, что если
ОС работает на одной машине -- с большой вероятностью она будет работать и
на других. В то же время, то, что ОС работает на виртуальной машине не
гарантирует, что она будет работать и на реальной. Однако для тестирования
на реальной машине необходимо либо тестировать на той же машине, на которой
ведется разработка (отнимает много времени, т.к. требуются постоянные
перезагрузки), либо приобрести вторую машину (не каждый может себе позволить).

Поэтому использование виртуальной машины является предпочтительным. Для
разработки ОС рекомендуют использовать Bochs или QEMU~\cite{os_dev}.

\subsection{Bochs}
Bochs -- это эмулятор платформы x86. Имеет следующие особенности~\cite{os_dev}:
\begin{itemize}
\item Автоматическая активация линии A20.
\item Автоматическое обнуление памяти. Bochs всегда заполняет память нулями, в то время как
	на реальных машинах такое, как правило не происходит.
\item Безошибочное чтение с диска. Чтения с диска в Bochs всегда проходят без ошибок, в то
	время как при чтении с реальных дисков, может потребоваться несколько раз повторить
	операцию чтения, прежде чем она окажется успешной.
\item Эмуляция только Intel/AMD64. Bochs эмулирует ЦП, поэтому команда CPUID всегда сообщает
	о том, что используется процессор Intel (для 32-битных систем) или AMD (для 64-битных систем),
	независимо от того, какой процессор установлен на хостовой машине.
\item Встроенный отладчик, возможность установки <<магических>> точек останова (xchg bx, bx),
	возможность вывода данных на экран, используя порты ввода/вывода, возможность переключения
	между процессорами.
\end{itemize}

\subsection{QEMU}
Эмулятор QEMU обладает следующими особенностями~\cite{os_dev}:
\begin{itemize}
\item Поддерживает эмуляцию различных архитектур: x86, ARM, MIPS, PowerPC, SPARC и др.
\item Встроенный монитор (позволяет переключаться между CPU; выводить содержимое регистров, кеша TLB,
	таблиц страничного преобразования и других системных структур данных).
\item Поддержка GDB (позволяет выполнять отладку на уровне исходных кодов).
\end{itemize}

\subsection{Выводы}
Каждый из описанных выше эмуляторов имеет свои достоинства и недостатки. Поэтому
было принято решение использовать оба.



%\section{Исполняемые форматы}
%http://wiki.osdev.org/ELF
%работаем в линухе, эльф - дефакто стандарт, берм его


\section{Организация рабочего окружения}
что использовал (gcc, gdb, qemu)

\section{Организация исходных кодов}
просто описание иерархии, что где должно лежать

\section{Система сборки}
иерархия мейкфайлов. наверно можно пару слов сказать
что-то надо сказать про скрипты линковщика

\section{Загрузка ОС}
\subsection{Начальная загрузка компьютера}
Процесс начальной загрузки ОС в ЭВМ архитектуры x86 не претерпел
принципиальных изменений за тридцать лет, прошедших с момента появления
первых IBM PC до начала внедрения загрузки на основе интерфейса EFI вместо
BIOS. Загрузка системы начинается с того, что после включения компьютера
управление передается на реальный адрес 0xFFFF\_FFF0~\cite{amd_pm_v2}, где находится
ПЗУ с кодом BIOS~\cite{mstu_os_dev_method}.

После того, как BIOS проинициализирует устройства, вектора прерываний реального
режима и выберет загрузочный дисковод или жесткий диск, она загружает его
первый сектор (512~байт) по адресу 0x7c00, после чего передает управление на
него (реальный адрес 0000:7c00). Два последних байта сектора должны иметь
значения 0x55 и 0xAA, иначе BIOS не сочтет сектор загрузочным. Таким образом,
размер начальной части загрузчика ОС фактически не может превышать 510~байт.

биос прыгает на 7с00, 2х этапный загрузчик, чтение с диска, почему все так + эльфы

\subsection{Организация памяти ОС}
нормальные люди называют это memory layout
продолжение загрузки

\section{Организация ввода/вывода}
как общаемся с терминалом

\section{Системные вызовы}
рассмотрю общее устройство, пару конкретных, наверно можно что-нибудь расскзать про форк

\section{Прерывания и многозадачность}
сюда же наверно приплести пользовательские процессы

\section{Потоки ядра}
просто небольшая фича

\section{Отладка}
.gdbinit
гдб становится плохо если в рантайме меняется набор инструкций, как это лечится.
