\chapter{Аналитический раздел}
\label{cha:analysis}

\section{История процессоров x86}
Первым процессором из линейки x86 был процессор Intel 8086 -- 16-разрядный процессор с адресным пространством
равным 1~Мб. За ним последовали 80186 и 80286 (i286), в последнем появился защищенный режим, в котором можно
было адресовать до 1~Гб памяти. Следующим был процессор 80386 (i386), который позволял адресовать 4~Гб физической
памяти и имел страничное преобразование (для реализации виртуального адресного пространства). Последующие
поколения добавляли новые возможности: встроенный сопроцессор, кэш-память, PAE, MMX, SSE, SSE2 и т.д.

В начале 2000-х годов стало очевидно, что 32-битного адресного пространства недостаточно для приложений,
работающих с большими объемами данных (например с видео и базами данных), т.к. в этом случае процессор
может использовать только 4~гигабайта виртуального адресного пространства.

Для решения этой проблемы компания Intel разработала спецификацию IA-64 (исользуется в процессорах семейства
Itanium). Для сохранения обработной совместимости с унаследованным 32-битным ПО, в данной архитектуре использовался
режим эмуляции, который уступал по производительности оригинальным процессорам x86.

Компания AMD предложила другое решение: она добавила 64-битное расширение к существующей 32-разрядной архитектуре x86.
Это позволило использовать физические адреса длинной до 52~бит (архитектурный предел). Данная архитектура была
названа x86-64, а затем переименована в AMD64.

Успех процессоров на базе AMD64 привел к тому, что Intel лицензировала набор инструкций AMD64. Новая версия архитектуры
получила название EM64T (IA-32e), позже была переименована в Intel 64.


\section{Режимы работы процессора}
Унаследованная (legacy) архитектура x86 предусматривает четыре режима работы процессора:
\begin{enumerate}[1.]
	\item Реальный режим (англ. Real Mode)
	\item Защищенный режим (англ. Protected Mode)
	\item Режим виртуального 8086 (англ. Virtual-8086 Mode)
	\item Режим системного управления (англ. System Management Mode)
\end{enumerate}

Архитектура AMD64 поддерживает все эти режимы и добавляет новый режим,
названный <<длинный>> режим (англ. Long Mode).


\subsection{Унаследованный режим}
Унаследованный режим состоит из трех подрежимов: реальный режим, защищенный режим и режим виртуального 8086.
Страничное преобразование в защищенном режиме не является обязательным. Унаследованный режим сохраняет
бинарную совместимость не только с существующим 16-битным и 32-битным прикладным ПО, но и с существующим
16-битным и 32-битным системым ПО.

\paragraph{Реальный режим.}
В данном режиме, также называемом режимом реальных адресов, процессору доступен 1~мегабайт физической памяти.
Обработка прерываний и формирование адреса выполняется так же, как и реальном режиме процессора 80286.
Страничное преобразование адреса не поддерживается. Все ПО выполняется на нулевом уровне привилегий.

Процессор начинает работу в реальном режиме.

\paragraph{Защищенный режим.}
В данном режиме процессору доступно 4~гигабайта физической и виртуальной памяти. Доступны все возможности
сегментного преобразования и аппаратного переключения задач. Если страничное преобразование не используется --
виртуальные адреса совпадают с физическими.

В защищенном режиме ПО выполняется на уровнях привилегий 0-3. Как правило, прикладное ПО выполняется на третьем
уровне привилегий, а системное - на 0, 1 и 2.


\subsection{Длинный режим}
Длинный режим включает в себя 2 подрежима: 64-битный режим и режим совместимости.
64-битный режим поддерживает несколько новых возможностей, включая возможность
использовать 64-битное адресное пространство. Режим совместимости обеспечивает
бинарную совместимость с существующим 16-битным и 32-битным прикладным ПО при работе
в 64-битном окружении.

Перед активацией и переходом в длинный режим, операционная система должна перейти в
защищенный режим. Процесс перехода в длинный режим описан в главе~\ref{sec:long_mode_activation}.

\subsection{64-битный режим}
64-битный режим -- подрежим длинного режима, предусматривает поддержку 64-разрядного
ПО. Режим имеет следующие особенности:
\begin{enumerate}[1.]
\item 64-битные виртуальные адреса.
\item Доступ к битам 63:32 регистров общего назначения.
\item Дополнительные 8 регистров общего назначения (R8-R15).
\item 64-битный счетчик команд (RIP).
\item Плоская модель памяти с одним сегментом кода, данных и стека.
\end{enumerate}

Данный режим может быть активирован системным ПО для различных сегментов кода. В данном режиме
механизм сегментного преобразования адреса отключен. Для управления памятью используется
механизм страничного преобразования.

Следует обратить внимание на то, что В 64-битном режиме процессор может использовать
52-битные физические адреса (архитектурный предел) и 64-битные виртуальные адреса (из них
только первые 48 бит используются механизмом страничного преобразования).

\subsection{Режим совместимости}
Режим совместимости -- подрежим длинного режима, позволяет системному ПО обеспечивать
бинарную совместимость с существущим 16-битным и 32-битным прикладным ПО,
т.е. запускать данное ПО без перекомпиляции в 64-битной ОС в длинном режим.

В режиме совместимости, приложениям доступны только первые 4 гигабайта виртуального адресного пространства.

В данном режиме сегментное преобразование адреса работает так же, как и в унаследованной
архитектуре x86. С точки зрения прикладного ПО, режим совместимости не отличается от унаследованного
защищенного режима. С точки зрения системного ПО -- необходимо использовать механизмы длинного режима для
преобразования адресов и обработки исключений и прерываний.

В данной работе режим совместимости будет использоваться только для перехода
в 64-битный режим.


\section{Системные ресурсы}
Операционная система выполняет системные операции (управление памятью, изменение режима работы процессора и др.)
используя системные ресурсы. Эти ресурсы состоят из системных регистров (управляющих и моделезависимых)
и системных структур данных (различные таблицы).

Для доступа к моделезависимым регистрам (англ. MSR) используются команды RDMSR и WRMSR.
Данные команды предполагают что в регистре ECX находится номер регистра. Команда RDMSR
сохраняет значение MSR в регистры EDX:EAX (все MSR имеют размер 64 бита). Команда WRMSR
записывает в регистр MSR значение, содержащееся в EDX:EAX.

\subsection*{Управляющие регистры}
Регистры, управляющие работой процессора в архитектуре AMD64, включают:
\begin{description}
	\item[CR0] Позволяет изменять ражим работы процессора и управляет некоторыми возможностями процессора.
	\item[CR2] Используется механизмом страничного преобразования. При возникновении страничного исключения, содержит
		виртуальный адрес по которому произошло исключение.
	\item[CR3] Используется механизмом страничного преобразования. Содержит базовый адрес таблицы страниц верхнего
		уровня, управляет кешированием данной таблицы.
	\item[CR4] Содержит дополнительные флаги для различных возможностей процессора.
	\item[CR8] Используется для управления приоритетами внешних прерываний.
	\item[RFLAGS] Хранит состояние процессора и некоторые управляющие флаги. В основном, используется для
		управления аппаратным переключением задач, прерываниями и режимом виртуального 8086.
	\item[EFER] моделезависимый регистр, содержащий состояние процессора и управляющие флаги, для
		возможностей, которые не управляются регистрами CR0 и CR4. Для доступа к данному MSR в регистр
		ECX нужно занести значение \textbf{0xC000\,0080}.
\end{description}

В унаследованном режиме все управляющие регистры, в т.ч. RFLAGS -- 32-битные. EFER -- 64-битный во всех режимах.
Архитектура AMD64 расширяет все 32-битные управляющие регистры до 64 бит.

Далее в работе под обозначением \textbf{rFLAGS} будет иметься в виду 16-битный, 32-битный или
64-битный регистр флагов. Аналогично, \textbf{rIP} -- 16-битный, 32-битный или 64-битный счетчик комманд.


\section{Сегментное преобразование адреса}
Унаследованная архитектура x86 поддерживает механизм сегментного преобразования адреса, который
позволяет системному ПО создавать отдельное виртуальное адресное пространство для каждого процесса.
Размер и расположение сегмента в виртуальном адресном пространстве произвольны. Инструкции и данные
могут располагаться как в одном, так и в нескольких сегментах, каждому из которых будут назначены
отдельные атрибуты доступа.

Механизм сегментного преобразования использует 10 сегментных регистров, каждый из которых
определяет один сегмент. 6 из этих регистров (CS, DS, ES, FS, GS и SS) определяют пользовательские сегменты.
Пользовательские сегменты содержат команды, данные и стек. Они доступны как для системного, так и для прикладного ПО.
Оставшиеся 4 регистра (GDTR, LDTR, IDTR и TR) определяют системные сегменты. Системные сегменты содержат структуры
данных инициализируемые и используемые только системным ПО. Сегментные регистры содержат (в теневой части)
базовый адрес, указывающий на начало сегмента, лимит сегмента и атрибуты доступа.

Несмотря на то, что сегментное преобразование обеспечивает высокую гибкость в изоляции и защите данных,
обычно, эти задачи решаются эффективнее с использованием программной и аппаратной
поддержки страничного преобразования. По этой причине большинство современных систем не используют
сегментное преобразование.

В длинном режиме, работа сегментного преобразования зависит от того, в каком из подрежимов находится процессор:
\begin{itemize}
\item В режиме совместимости сегментное преобразование работает так же, как и в унаследованном режиме.
\item В 64-битном режиме сегментное преобразование отключено, задавая плоское 64-битное адресное пространство.
	Однако некоторые функции сегментых регистров (в частности системных сегментных регистров) продолжают использоваться.
\end{itemize}

Системное ПО может использовать механизм сегментного преобразования для реализации одной из двух основных
моделей: плоская модель памяти (используется один сегмент) и мульти-сегментная модель памяти
(используется несколько сегментов).

\subsubsection*{Плоская модель памяти}
Плоская модель памяти -- это простейшая форма сегментного преобразования. Плоская модель памяти позволяет
системному ПО обойти часть механизмов сегментного преобразования. В плоской модели памяти все базовые адреса
сегментов равны 0, а лимиты сегментов равны 4 гигабайтам. Установка базового адреса сегмента в 0 фактически
отключает сегментное преобразование (сегмент:смещение = смещение).

\subsubsection*{Сегментное преобразование в 64-битном режиме}
В 64-битном режиме сегментное преобразование отключено. Аппаратное обеспечение игнорирует значение
базового адреса сегмента и обрабатывает его как 0. Игнорируются размер и большинство атрибутов.
Системные сегментные регистры всегда используются в 64-битном режиме.

\subsection{Структуры данных сегментного преобразования}
Механизм сегментного преобразования использует следующие структуры данных:
\begin{itemize}
\item Дескрипторы сегментов. Описывают сегменты (базовый адрес сегмента в виртуальном
	адресном пространстве, его лимит, атрибуты доступа и некоторые другие характеристики).
\item Таблицы дескрипторов. Сегментные дескрипторы хранятся в памяти в одной из трех таблиц: GDT, LDT, IDT.
\item Сегмент состояния задачи (TSS). Cпециальный тип системного сегмента, который содержит
	информацию о состоянии процесса (задачи), в т.ч. ссылки на необходимые процессу структуры данных.
\item Сегментные селекторы. Используются для выбора дескрипторов из таблиц дескрипторов.
\end{itemize}

Механизм сегментного преобразования использует следующие регистры: CS, DS, ES, SS, GS, FS, GDTR, IDTR, LDTR, TR.
Структуры данных связаны с регистрами следующим образом:
\begin{itemize}
	\item Сегментные регистры (CS, DS, ES, FS, GS, SS). Используются чтобы ссылаться
		на пользовательские сегменты. При загрузке селектора сегмента в сегментный регистр процессор
		автоматически загружает выбранный дескриптор в теневую часть сегментного регистра.
	\item Регистры таблиц дескрипторов (GDTR, LDTR, IDTR). Задают виртуальный базовый адрес и лимит таблиц дескрипторов.
	\item Регистр задачи (TR). Задает положение и размер текущего сегмента состояния задачи (TSS).
\end{itemize}

\subsubsection*{Сегментные селекторы}
Селекторы сегментов указывают на дескрипторы в GDT и LDT.
Формат селектора сегмента показан на рис.~\ref{fig:segment-selector}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.4\textwidth]{inc/dia/segment-selector}
  \caption{Формат селектора сегмента}
  \label{fig:segment-selector}
\end{figure}

Селектор состоит из следующих полей:
\begin{enumerate}[1.]
\item Индекс. Биты 15:3. Указывает на элемент в таблице дескрипторов.
	Дескрипторы имеют размер 8~байт, поэтому индекс умножается на 8
	чтобы получить смещение в таблице дескрипторов. Смещение прибавляется
	к базовому адресу GDT или LDT (в зависимости от значения TI), чтобы получить
	виртуальный адрес дескриптора.

	Некоторые элементы таблицы дескрипторов имееют размер 16~байт, вместо 8.
	Они занимают 2 элемента в таблице. Однако в длинном режиме смещение по
	прежнему вычисляется путем умножения индекса на 8. Системное ПО должно
	назначать селекторы так, чтобы они указывали на начало расширенных элементов.
\item Индикатор таблицы (TI). Бит 2. Указывает в какой таблице хранится дескриптор.
	Если бит сброшен в 0, это означает что селектор ссылается на запись в GDT.
	Иначе - селектор ссылается на запись в LDT.
\item Уровень привилегий (RPL). Биты 1:0. Равен уровню привилегий на котором
	находился процессор (CPL) при создании селектора. Используется для проверки прав доступа.
\end{enumerate}

Нулевые селекторы (индекс 0 и TI=0) используются чтобы сделать сегментные
регистры недействительными (аналог нулевых указателей).
При использовании сегментного регистра (не в 64-битном режиме),
содержащего нулевой селектор произойдет исключение \#GP.

\subsubsection*{Сегментные регистры}
Для улучшения производительности, при загрузке нового значения в сегментный регистр,
процессор загружает дескриптор, соответсвующий селектору, в теневую часть сегментного регистра.
Благодаря этому снижается число обращений к памяти.

На рис.~\ref{fig:segment-register-format-x86} показаны видимая и теневая части сегментного регистра.
ПО не имеет прямого доступа к теневой части сегментных регистров (кроме GS и FS).

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.4\textwidth]{inc/dia/segment-register-format-x86}
  \caption{Формат сегментного регистра}
  \label{fig:segment-register-format-x86}
\end{figure}

При вычислении адреса, базовый адрес считается равным 0, выход за пределы сегмента не проверяется.
Вместо этого выполняется проверка, что адрес находится в канонической форме. Содержимое теневой части
регистров DS, ES и SS игнорируется полностью.

\subsection{Таблицы дескрипторов}
Механизм сегментного преобразования использует таблицы дескрипторов.
Эти таблицы содержат дескрипторы, которые описывают расположение сегмента в виртуальной памяти,
его лимит (размер - 1) и атрибуты доступа. Обращение к полям дескриптора происходит при каждом
обращении к памяти (выборка инструкций, чтение/запись данных).

Как было сказано ранее, архитектура x86 поддерживает 3 типа таблиц дескрипторов: GDT, LDT (как правило, не используется), IDT.

\subsubsection*{GDT}
Для перехода в защищенный режим необходимо создать GDT. GDT содержит дескрипторы
сегментов кода и данных для сегментов, которые являются общими для всех задач.
Кроме пользовательских сегментов, GDT может содержать дескрипторы шлюзов и
другие системные дескрипторы. Системное ПО может расположить GDT в произвольной
области памяти, недоступной непривилегированному ПО.

На рис.~\ref{fig:gdt-ldt-access} показано как происходит доступ к GDT/LDT.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/gdt-ldt-access}
  \caption{Доступ к GDT/LDT}
  \label{fig:gdt-ldt-access}
\end{figure}

\subsubsection*{Регистр глобальной таблицы дескрипторов}
Регистр GDT (GDTR) содержит базовый адрес и размер GDT. Регистр загружается командой LGDT.
На рис.~\ref{fig:gdtr-idtr-legacy-format} показан формат GDTR в унаследованном режиме и
режиме совместимости. На рис.~\ref{fig:gdtr-idtr-x64-format} показан формат GDTR в длинном режиме.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.4\textwidth]{inc/dia/gdtr-idtr-legacy-format}
  \caption{Формат GDTR и IDTR в унаследованном режиме}
  \label{fig:gdtr-idtr-legacy-format}
\end{figure}

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.9\textwidth]{inc/dia/gdtr-idtr-x64-format}
  \caption{Формат GDTR и IDTR в длинном режиме}
  \label{fig:gdtr-idtr-x64-format}
\end{figure}

GDTR состоит из двух полей:
\begin{description}
\item[Лимит] 2 байта. Задает лимит GDT в байтах. При обращении ПО за пределы GDT произойдет
	исключение \#GP.
\item[Базовый адрес] 8 байт. Содержит виртуальный адрес начала таблицы. GDT может быть расположена
	по любому адресу, однако системному ПО следует использовать адрес, выровненный по 4-байтной границе,
	чтобы избежать снижения производительности из-за доступа к невыровненным данным.
\end{description}

В архитектуре AMD64 размер базового адреса в GDTR увеличен до 64 бит, что позволяет системному ПО,
работающему в длинном режиме, расположить GDT в произвольном месте 64-битного адресного пространства.
В унаследованном режиме процессор игнорирует старшие 4 байта.


\subsubsection*{IDT}
IDT, так же как GDT и LDT, может быть расположена в произвольной области памяти, недоступной непривилегированному ПО.

IDT может содержать дескрипторы следующих типов:
\begin{itemize}
	\item Шлюз прерывания (англ. interrupt gate)
	\item Шлюз ловушки (англ. trap gate)
	\item Шлюз задачи (англ. task gate)
\end{itemize}

В главе ~\ref{sec:exceptions_and_interrupts} описано,
как механизм обработки прерываний использует дескрипторы шлюзов.

Обращение к элементам IDT происходит по номеру вектора прерывания. Смещение в таблице вычисляется путем
умножения номера вектора прерывания на размер элемента таблицы. Размер элемента таблицы зависит от
режима работы процессора следующим образом:
\begin{itemize}
\item В длинном режиме размер элемента IDT составляет 16 байт.
\item В унаследованном режиме размер элемента IDT составляет 8 байт.
\end{itemize}

На рис.~\ref{fig:indexing-an-idt} показано, как происходит индексация в IDT по номерy вектора прерывания.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/indexing-an-idt}
  \caption{Индексация в IDT}
  \label{fig:indexing-an-idt}
\end{figure}


\subsubsection*{Регистр IDT}
Регистр IDT (IDTR) содержит базовый адрес и размер IDT.
Содержимое регистра загружается командой LIDT. Формат IDTR совпадает с форматом GDTR во
всех режимах работы процессора. На рис.~\ref{fig:gdtr-idtr-legacy-format} показан формат
IDT в унаследованном режиме, а на рис.~\ref{fig:gdtr-idtr-x64-format} -- в длинном режиме.

\subsection{Унаследованные дескрипторы сегментов}
\subsubsection*{Формат дескриптора}
Дескрипторы сегментов определяют и изолируют сегменты друг от друга. Существует 2 основных типа
дескрипторов, каждый из которых используется для описания сегментов (шлюзов) разных типов:
\begin{itemize}
	\item Дескрипторы пользовательских сегментов -- дескрипторы сегментов кода и данных (в т.ч. стека).
	\item Дескрипторы системных сегментов -- дескрипторы LDT, TSS и шлюзов (описывают программные точки входа).
\end{itemize}

На рис.~\ref{fig:legacy-segment-descriptor-format} показан общий формат дескриптора сегмента в унаследованном режиме.
В унаследованном режиме размер сегмента составляет 8 байт (2 двойных слова). На рисунке старшее двойное слово (смещение +4)
изображено вверху, младшее -- внизу.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/legacy-segment-descriptor}
  \caption{Общий формат дескриптора в унаследованном режиме}
  \label{fig:legacy-segment-descriptor-format}
\end{figure}

Дескриптор имеет следующие поля:
\begin{itemize}
\item Лимит сегмента. 20-битный лимит сегмента формируется путем объединения
	бит 19:16 старшего двойного слова и 0:15 младшего двойного слова.
\item Базовый адрес. 32-битный базовый адрес формируется путем объединения бит 31:24 и 7:0 старшего двойного слова
	с битами 15:0 младшего двойного слова. Содержит адрес начала сегмента в виртуальной памяти.
\item Бит <<S>>. Если равен 0 -- системный сегмент (LDT, TSS, шлюз), иначе -- пользовательский (код, данные).
\item <<Тип>>. Определяет тип сегмента.
\item <<DPL>>. Определят уровень привилегий дескриптора. Может иметь значения от 0 до 3, где 0 -- наибольший
	уровень привилегий, 3 -- наименьший.
\item Бит <<P>>. Определяет присутствует (загружен) ли сегмент в памяти.
\item <<AVL>>. Доступно для использования системным ПО.
\item Бит <<D/B>>. Размер операнда по умолчанию.
\item Бит <<G>>. Бит гранулярности -- опредяет как обрабатывать размер сегмента. Если равен 0 -- размер сегмента
	задается в байтах. Если равен 1 -- размер сегмента задан в 4-килобайтных блоках.
\end{itemize}

\subsubsection*{Дескрипторы сегментов кода}
На рис.~\ref{fig:legacy-code-segment-descriptor-format} показан формат дескриптора сегмента кода.
Сегменты кода определяют режим работы процессора и уровень привилегий. Сегменты кода доступны только для исполнения,
либо только для чтения и исполнения. Запись в сегмент кода, на который ссылается регистр CS, запрещена.
\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/legacy-code-segment-descriptor}
  \caption{Формат дескриптора сегмента кода в унаследованном режиме}
  \label{fig:legacy-code-segment-descriptor-format}
\end{figure}

Для дескрипторов сегментов кода бит <<S>> установлен в 1, означая что это пользовательский сегмент. Бит 11
используется чтобы отличать сегменты кода и сегменты данных (если бит установлен в 1 -- это сегмент кода).
Биты 10:8 определяют характеристики доступа к сегменту кода:
\begin{itemize}
	\item Бит <<C>>. Управляет CPL при передаче управления.
	\item Бит <<R>>. Разрешает чтение данных из сегмента.
	\item Бит <<A>>. Устанавливается при копировании дескриптора в регистр CS.
\end{itemize}

\subsubsection*{Дескрипторы сегментов данных}
На рис.~\ref{fig:legacy-data-segment-descriptor-format} показан формат дескриптора сегмента данных.
Сегменты данных могут быть доступны либо только для чтения, либо для чтения/записи. Доступ к сегментам
данных осуществляется с использованием регистров DS, ES, FS, GS, SS. Регистр DS содержит селектор
сегмента данных, используемый по умолчанию.

Сегмент стека это одна из форм сегмента данных. Доступ к нему осуществляется через регистр SS. Он должен
быть доступен для чтения и записи.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/legacy-data-segment-descriptor}
  \caption{Формат дескриптора сегмента данных в унаследованном режиме}
  \label{fig:legacy-data-segment-descriptor-format}
\end{figure}

Для дескрипторов сегментов данных бит <<S>> установлен в 1, означая что это пользовательский сегмент. Бит 11
сброшен в 0, обозначая сегмент данных. Биты 10:8 определяют характеристики доступа к сегменту:
\begin{itemize}
	\item Бит <<E>>. Определяет расширяющийся вниз сегмент.
	\item Бит <<W>>. Разрешает операции записи в сегменте.
	\item Бит <<A>>. Устанавливается при копировании дескриптора в DS, ES, FS, GS или SS.
\end{itemize}

\subsection{Сегментные дескрипторы длинного режима}
\subsubsection*{Дескрипторы сегмента кода}
В длинном режиме сегменты кода продолжают использоваться. Сегменты кода, их дескрипторы и селекторы
необходимы для установки режима работы процессора и уровня привилегий. Атрибут <<L>> определяет в
каком режиме работает процессор -- в 64-битном или режиме совместимости.
На рис.~\ref{fig:long-mode-code-segment-descriptor-format} показан формат дескриптора сегмента кода
в длинном режиме. В режиме совместимости все поля дескриптора интерпретируются так же, как и в унаследованном режиме.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-code-segment-descriptor}
  \caption{Формат дескриптора сегмента кода в длинном режиме}
  \label{fig:long-mode-code-segment-descriptor-format}
\end{figure}

\paragraph{Игнорируемые в 64-битном режиме поля.}
В 64-битном режиме сегментное преобразование отключено, сегменты кода занимают все адресное пространство.
В этом режиме значение поля <<базовый адрес>> игнорируется. При вычислении виртуального адреса оно считается равным 0.

Проверка выхода за границу сегмента не выполняется, игнорируются размер и бит <<G>>. Вместо этого выполняется
проверка, что адрес находится в канонической форме.

Также игнорируются биты <<R>> и <<A>> в поле <<тип>>.

\paragraph{Бит <<L>>.} В длинном режиме у дескриптора кода появился дополнительный атрибут -- бит <<L>>. Если он равен 1 --
процессор работает в 64-битном режиме, иначе -- в режиме совместимости. В унаследованном режиме этот бит игнорируется.

Режим совместимости имеет бинарную совместимость с существующим 16-битным и 32-битным прикладным ПО.
Переход в режим совместимости осуществялется на основании атрибутов сегмента кода, это позволяет
64-битному системному ПО исполнять унаследованное ПО вместе с 64-битным ПО. Для запуска унаследованных
16-битных и 32-битных приложений системному ПО достаточно сбросить бит <<L>> в дескрипторе сегмента кода в 0.

Если процессор работает в 64-битном режиме (L=1) -- бит <<D>> должен быть равен 0. Это приводит к тому,
что размер операнда по умолчанию составляет 32 бита, а размер адреса по умолчанию составляет 64 бита.
Комбинация L=1 и D=1 зарезервирована для использования в будущем.

\subsubsection*{Дескрипторы сегмента данных}
В длинном режиме сегменты данных продолжают использоваться. На рис.~\ref{fig:long-mode-data-segment-descriptor-format}
показан формат дескриптора сегмента данных в длинном режиме. В режиме совместимости все поля дескриптора
интерпретируются также, как и в унаследованном режиме.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-data-segment-descriptor}
  \caption{Формат дескриптора сегмента данных в длинном режиме}
  \label{fig:long-mode-data-segment-descriptor-format}
\end{figure}

\paragraph{Игнорируемые в 64-битном режиме поля.}
В 64-битном режиме сегментное преобразование отключено. Интерпретация базового адреса зависит от
используемого сегментного регистра:
\begin{itemize}
\item При использовании регистров DS, ES, SS поле <<базовый адрес>> игнорируется и считается равным 0.
\item Регистры GS и FS обрабатываются специальным образом. При использовании этих регистров можно
	использовать ненулевое значение базового адреса для вычисления виртуального адреса.
\end{itemize}

Игнорируются все атрибуты дескриптора, кроме бита <<P>>.

\subsubsection*{Системные дескрипторы}
\label{subsec:system_desriptor_format}

Как показано на рис.~\ref{fig:long-mode-system-segment-descriptor-format} в 64-битном режиме
системные дескрипторы LDT и TSS увеличены на 64 бита. Увеличение дескрипторов, позволяет
хранить в них 64-битный базовые адреса, поэтому сегменты, которые они описывают могут быть
расположены в произвольном месте в памяти. Расширенные дескрипторы могут быть загружены в
соответствующие регистры (LDTR или TR) только из 64-битного режима.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-system-segment-descriptor}
  \caption{Формат системного дескриптора в длинном режиме}
  \label{fig:long-mode-system-segment-descriptor-format}
\end{figure}

Базовый адрес 64-битного системного сегмента должен быть в канонической форме, иначе при
загрузке сегмента произойдет исключение \#GP. Выход за границу системного сегмента проверяется и
в 64-битном режиме и в режиме совместимости с учетом бита гранулярности <<G>>.

На рис.~\ref{fig:long-mode-system-segment-descriptor-format} показано, что биты 12:8 двойного слова +12
должны быть сброшены в 0. Эти биты соотвествуют биту <<S>> и полю <<тип>> в унаследованном дескрипторе.
Сброс этих бит в 0 соответствует неправильному типу дескриптора в унаследованном режиме и приведет
к возникновению исключения \#GP при попытке обратиться отдельно к старшей половине 64-битного системного сегмента.

\subsubsection*{Дескрипторы шлюзов}
В длинном режиме дескрипторы шлюзов увеличены на 64 бита, что позволяет хранить в них 64-битные смещения.
Формат 64-битного дескриптора шлюза прерывания и шлюза ловушки показан на рис.~\ref{fig:long-mode-interrupt-gate-descriptor}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-interrupt-gate-descriptor}
  \caption{Формат дескриптора шлюза прерывания и шлюза ловушки в длинном режиме}
  \label{fig:long-mode-interrupt-gate-descriptor}
\end{figure}

Селектор сегмента (в дескрипторе шлюза) должен указывать на 64-битный сегмент кода (CS.L=1, CS.D=0).
В противном случае, при обращении к дескриптору произойдет исключение \#GP.

Исключение также возникает, если адрес, содержащийся в поле <<смещение>>, находится не в канонической форме.

В 64-битном режиме элементы таблицы векторов прерываний имеют размер 128 бит. Процессор автоматически
умножает номер вектора прерывания на 16 для определения смещения.

\paragraph{Поле <<IST>>.} Биты 2:0 байта +4. В длинном режиме в дескрипторах шлюзов прерываний и ловушек
появилось новое 3-битное поле -- IST. Данное поле используется в качестве индекса в IST фрагменте TSS длинного режима.
Если IST не равно 0 -- индекс ссылается на элемент IST в TSS, значение которого процессор загружает в регистр RSP при
возникновении прерывания. Если IST равно 0 -- процессор использует унаследованный механизм переключения стека.

\subsection{Защита сегментов}
Архитектура AMD64 разработана, чтобы полностью поддерживать унаследованный механизм защиты сегментов.
Данный механизм позволяет системному ПО ограничивать процессам доступ к данным и коду других процессов.

Защита на уровне сегментов включена в режиме совместимости. 64-битный режим устраняет часть проверок,
оставляя только проверки доступа к таблицам системных дескрипторов.

Предпочтительный метод организации защиты памяти в операционной системе длинного режима -- использование
механизма страничного преобразования.

\subsubsection*{Концепция уровней доступа}
Механизм защиты сегментов используется чтобы изолировать и защищать код и данные различных процессов. В защищенном
режиме (CR0.PE=1) данный механизм поддерживает 4 уровня привилегий. Уровни привилегий обозначаются номерами от 0 до 3,
где 0 обозначает наибольший уровень привилегий, 3 -- наименьший. Как правило, уровень 0 используется системным ПО,
уровень 3 -- прикладным ПО, а уровни 1 и 2 не используются.

\subsubsection*{Типы уровней привилегий}
Существует три типа уровней привилегий, используемых процессором для контроля доступа к сегментам: CPL, DPL и RPL.

\paragraph{CPL.} Текущий уровень привилегий -- уровень привилегий, на котором процессор находится в данный
момент. Он хранится во внутреннем регистре процессора, недоступном для ПО. Изменить текущий уровень привилегий
можно путем передачи управления на сегмент кода с другим уровнем привилегий.

\paragraph{DPL.} Уровень привилегий дескриптора -- уровень привилегий, который системное ПО назначает сегменту (шлюзу).
Используется при проверке прав доступа, чтобы определить можно ли приложению обращаться к сегменту (шлюзу), на который
ссылается дескриптор. Данное поле хранится в дескрипторе сегмента (шлюза).

\paragraph{RPL.} Отражает уровень привилегий процесса, который создал селектор сегмента (шлюза). RPL может быть использован
в вызываемой программе, чтобы определить уровень привилегий вызывающей программы. Данное поле хранится
в селекторе сегмента (шлюза).

Дополнительная информация о проверках прав доступа с использованием CPL, DPL и RPL приведена в \cite{amd_pm_v2}.



\section{Страничное преобразование}
\label{sec:page_translation}
Механизм страничного преобразования x86 позволяет системному ПО создавать отдельные адресные
пространства для различных процессов. Эти адресные пространства известны как
виртуальные адресные пространства. Системное ПО использует механизм страничного преобразования
для отображения вируальных страниц на физические, используя иерархию таблиц страничного преобразования,
известных как таблицы страниц.

Механизм страничного преобразования и таблицы страниц используются чтобы обеспечить
каждый процесс областью физической памяти для хранения кода и данных, недоступной другим процессам.
Процесс не может получить доступ к физической памяти, которая не отображена в его адресное
пространство системным ПО.

Системное ПО может использовать механизм страничного преобразования чтобы отобразить одну физическую
страницу в различные адресные пространства. Такие страницы можно делать доступными только для чтения,
чтобы предотвратить их модификацию процессами.

Общие страницы, как правило, используются для организации доступа к разделяемым библиотекам из
разных процессов. Доступная только для чтения копия библиотеки отображается в виртуальное адресное
пространство каждого процесса, однако в физической памяти находится только одна копия библиотеки.
Данная возможность также позволяет хранить копию операционной системы и различных драйверов устройств
в адресном пространстве процессов. Это позволяет избежать накладных расходов связанных с переключением
на другое адресное пространство при обращении к функциям ОС.

Область адресного пространства, отведенная для системного ПО, содержит системные данные, которые
должны быть недоступны для прикладного ПО. Системное ПО использует таблицы страниц для защиты этих
данных, отмечаяя такие страницы как доступные только супервизору, тем самым запрещая доступ к ним со
стороны прикладного (непривилегированного) ПО.

Системное ПО может использовать механизм страничного преобразования, чтобы отображать большие
виртуальные адресные пространства в меньший объем физической памяти. Каждому процессу доступно
32-битное или 64-битное виртуальное адресное пространство. Системное ПО использует свободные
физические страницы для отображения наиболее часто используемых виртуальных страниц. Наименее часто
используемые виртуальные страницы выгружаются на диск.

\subsection{Механизм страничного преобразования}
Унаследованная архитектура x86 поддерживает преобразование 32-битных виртуальных адресов в 32-битные физические.
Архитектура AMD64 расширяет эту возможность, позволяя преобразовывать 64-битные виртуальные адреса в 52-битные
физические (различные реализации процессоров могут поддерживать более короткие виртуальные и физические адреса).

Виртуальные адреса преобразуются в физические, используя иерархию таблиц страниц, созданную и управляемую системным ПО.
Элементы таблиц указывают на таблицы страниц следующего уровня. Одна таблица может содержать до 1024 элементов,
каждый из которых указывает на таблицу страниц следующего уровня. Элементы таблицы страниц заключительного уровня
указывают на физические страницы.

На рис.~\ref{fig:long-mode-4kb-page-translation} показана иерархия таблиц страниц, использующаяся в длинном режиме.
Как показано на рисунке, виртуальный адрес делится на несколько частей, каждая из которых используется как смещение
в соответствующей таблице страниц. Младшая часть виртуального адреса испльзуется как смещение в физической странице.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-4kb-page-translation}
  \caption{Использование 4-килобайтных страниц в длинном режиме}
  \label{fig:long-mode-4kb-page-translation}
\end{figure}

\subsubsection*{Опции страничного преобразования}
Режим страничного преобразования зависит от того, какие опции были активированы. Существует
4 опции, влияющие на страничное преобразование:
\begin{itemize}
	\item Активация страничного преобразования (бит CR0.PG)
	\item Расширение физических адресов (бит CR4.PAE)
	\item Расширение размеров страниц (бит CR4.PSE)
	\item Активация длинного режима (бит EFER.LMA)
\end{itemize}

\subsubsection*{Активация страничного преобразования}
Страничное преобразование управляется битом <<PG>> регистра CR0 (бит 31). Если бит CR0.PG установлен в 1 --
страчное преобразование включено, иначе -- выключено.

\subsubsection*{Расширение физических адресов (бит <<PAE>>)}
Возможность расширения физических адресов управляется битом <<PAE>> в регистре CR4 (бит 5). Если бит CR4.PAE
установлен в 1 -- использется расширение физических адресов, в противном случае -- не используется.

Установка CR4.PAE в 1 включает поддержку преобразования виртуальных адресов в 52-битные физические адреса.
Это приводит к увеличению длинны полей структур данных страничного преобразования с 32 бит до 64 (для
возможности хранения расширенных физических адресов).


\subsection{Страничное преобразование в длинном режиме}
Для работы страничного преобразования в длинном режиме необходимо использовать PAE.
CR4.PAE должен быть установлен в 1 до перехода в длинный режим, в противном случае
произойдет исключение \#GP.

Структуры данных страничного преобразования при включенном PAE позволяют отображать 64-битные
виртуальные адреса в 52-битные физические. PAE расширяет элементы каталога страниц (PDE) и
элементы таблицы страниц (PTE) до 64 бит, позволяя использовать физические адреса длинной более 32 бит.

Архитектура AMD64 расширяет формат PDPE, определяя ранее зарезервированные биты.
Также была добавлена таблица страниц 4го уровня (PML4).

Так как в длинном режиме PAE всегда включен -- бит <<PS>> в элементах каталога страниц (PDE.PS)
позволяет выбирать между 4-килобайтными и 2-мегабайтными страницами.

\subsubsection*{Регистр CR3}
В длинном режиме регистр CR3 используется для указания базового адреса PML4. Размер регистра CR3 был
увеличен до 64 бит, чтобы иметь возможность хранить PML4 в произвольном месте физического
адресного пространства. На рис.~\ref{fig:long-mode-cr3} показан формат регистра CR3 в длинном режиме.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-cr3}
  \caption{Формат регистра CR3 в длинном режиме}
  \label{fig:long-mode-cr3}
\end{figure}

Регистр CR3 имеет следующие поля:
\begin{itemize}
\item Базовый адрес. Содержит физический адрес таблицы страниц верхнего уровня. Это 40-битное поле, занимает биты
	51:12 и указывает на начало PML4. Адрес PML4 выровнен по 4-килобайтной границе (младшие 12 бит равны 0).
\item Бит <<PWT>> (3). Бит сквозной записи. Определяет политику кеширования.
\item Бит <<PCD>> (4). Бит отключения кеширования.
\item Зарезервированные поля. Должны быть сброшены в 0 при записи нового значения в регистр CR3.
\end{itemize}

\subsubsection*{Использование 4-килобайтных страниц}
При использовании 4-килобайтных физических страниц в длинном режиме виртуальный адрес делится на 6 частей.
4 из них используются в качестве индексов в таблицах страниц. Как показано на рис.~\ref{fig:long-mode-4kb-page-translation},
поля виртуального адреса используются следующим образом:
\begin{itemize}
\item Биты 63:48 -- знаковое расширение бита 47, как этого требует каноническая форма адреса.
\item Биты 47:39 -- индекс в PML4.
\item Биты 38:30 -- индекс в PDP.
\item Биты 29:21 -- индекс в каталоге страниц.
\item Биты 20:12 -- индекс в таблице страниц.
\item Биты 11:0 -- смещение в физической странице.
\end{itemize}

На рис.~\ref{fig:long-mode-4kb-pte} показан формат элемента таблицы страниц.

Каждая таблица имеет размер 4~килобайта и содержит 512 64-битных элементов. Поля этих элементов
описаны в ~\ref{subsec:page_table_fields}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/long-mode-4kb-pte}
  \caption{Элемент таблицы страниц при использовании 4-килобайтных страниц в длинном режиме}
  \label{fig:long-mode-4kb-pte}
\end{figure}

\subsection{Поля элементов таблиц страниц}
\label{subsec:page_table_fields}
Элементы таблиц страниц содержат контрольные и информационные поля, используемые для управления
страницами в виртуальной памяти.

\paragraph{Базовый адрес таблицы страниц.} Содержит физический адрес таблицы страниц следующего уровня.
Адреса таблиц страниц всегда выровнены по границе 4 килобайта, поэтому необходимо хранить только биты, старше 11
(т.к. биты 11:0 всегда равны 0).

\paragraph{Базовый адрес страницы.} Содержит базовый адрес физической страницы. Страницы могут иметь размер 4~Кб, 2~Мб,
4~Мб или 1~Гб. Их адреса всегда выровнены по границе равной размеру страницы.

\paragraph{Бит <<P>>.} Бит 0. Показывает находится ли таблица/физическая страница в памяти. Если сброшен в 0 --
таблицы/физической страницы в памяти нет.

ОС сбрасывает этот бит, чтобы показать, что таблица/страница выгружена. При доступе к такой таблице/странице произойдет страничное
исключение (\#PF). ОС должна загрузить отсутсвующую страницу/таблицу в память и установить данный бит в 1.

Когда этот бит сброшен в 0 -- все остальные биты доступты для ОС. Такие страницы никогда не модифицируются процессором и
не попадают в TLB.

\paragraph{Бит <<R/W>>.} Бит 1. Этот бит контролирует возможность чтения/записи для всех физических страниц, отображенных
данным элементом таблицы. Если бит установлен в 1 -- страницы доступны для чтения и записи, в противном случае --
только для чтения.

\paragraph{Бит <<U/S>>.} Бит 2. Этот бит контролирует возможность доступа непривилегированного ПО (CPL=3) ко всем страницам,
отображенным данным элементом таблицы. Если бит установлен в 1 -- доступ разрешен для всех уровней привелений,
в противном случает -- только для уровней привилегий 0, 1 и 2.

\paragraph{Бит <<PWT>>.} Бит 3. Определяет политику кеширования таблицы/страницы.

\paragraph{Бит <<PCD>>.} Бит 4. Отключает кеширование таблицы/страницы.

\paragraph{Бит <<A>>.} Бит 5. Показывает был ли доступ к таблице/странице.

\paragraph{Бит <<D>>.} Бит 6. Показывает была ли страница модифицирована.

\paragraph{Бит <<PS>>.} Бит 7. Позволяет изменять размер используемых страниц.

\paragraph{Бит <<G>>.} Бит 8. Определяет является ли страница глобальной.

\paragraph{Биты <<AVL>>.} Данные биты доступны для использования системным ПО.

\paragraph{Бит <<PAT>>.} Используется механизмом страничных атрибутов.

\paragraph{Бит <<NX>>.} Бит 63. Запрещает исполнение кода на странице.

\paragraph{Зарезервированные биты.} Должны быть сброшены в 0.

\subsection{Кеш TLB}
При включенном страничном преобразовании виртуальные адреса автоматически преобразуются в физические,
используя иерархию таблиц страниц. Кеши TLB, служат для уменьшения накладных расходов, связанных с преобразованием.
TLB -- аппаратный кеш, который содержит результаты последних отображений виртуальных адресов в физические.
При каждом обращении к памяти, адрес проверяется в TLB. Если отображение найдено -- результат немедленно возвращается
процессору, это позволяет избежать лишних обращений к памяти (для доступа к таблицам страниц).

Системное ПО должно инвалидировать записи в TLB при внесении изменений в структуры данных страничного
преобразования (при удалении отображения, изменении виртуального адреса, либо ограничении прав доступа).


\section{Сегмент состояния задачи (TSS)}
\label{sec:task_state}

Задача (также называемая процессом) это программа, которую процессор может
исполнять, приостанавливать и позже продолжать исполнение с места последней
остановки. Пока задача приостановлена могут исполняться другие задачи. Каждая
задача имеет свой контекст, в который входят: rIP, rFLAGS, CR3, сегмент кода
и данный и некоторые другие ресурсы.

\subsection{Ресурсы управления задачами}
В длинном режиме операционная система должна инициализировать некоторые ресурсы
управления задачами:
\begin{enumerate}[1.]
\item Сегмент состояния задачи (TSS) -- сегмент, в котором хранится состояние
	процессора, связанное задачей.
\item Дескриптор TSS -- дескриптор сегмента, описывающий TSS. Формат описан ранее в
	главе~\ref{subsec:system_desriptor_format}.
\item Селектор TSS -- селектор сегмента, который ссылается на дескриптор TSS,
	расположенный в GDT, т.е. бит TI всегда равен 0.
\item Регистр задачи (TR) -- регистр, в котором хранится селектор и дескриптор
	TSS текущей задачи.
\end{enumerate}


\subsubsection*{Регистр задачи (TR)}
Регистр задачи хранит адрес TSS, определяет его лимит и атрибуты. TR состоит
из двух частей -- видимой и теневой. В видимой (доступной для ПО) части хранится селектор TSS,
теневая часть содержит дескриптор TSS. При загрузке селектора TSS в TR
процессор автоматически загружает дескриптор TSS из GDT в теневую часть.
Загрузка нового значения в TR осуществляется инструкцией LTR. На
рис.~\ref{fig:task_register} показан формат TR в длинном режиме.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=.8\textwidth]{inc/dia/task-register}
  \caption{Формат регистра задачи (TR)}
  \label{fig:task_register}
\end{figure}

\subsubsection*{Формат TSS}
Системное ПО должно создать как минимум один TSS для использования в длинном режиме и
выполнить инструкцию LTR в 64-битном режиме, чтобы загрузить в TR 64-битный TSS.

TSS включает следующую информацию:
\begin{enumerate}[1.]
\item RSPn -- Байты 0x1B-0x04. 64-битные адреса указателей стека (RSP) для
	уровней привилегий 0,1 и 2.
\item ISTn -- Байты 0x5B-0x24. 64-битные адреса указателей стека, используемые
	механизмом IST.
\item Базовый адрес битовой карты разрешений ввода/вывода. Байты 0x67-0x66.
\end{enumerate}



\section{Исключения и прерывания}
\label{sec:exceptions_and_interrupts}

Исключения и прерывания приводят к передаче управления функциям операционной
системы. Эти функции называются обработчиками исключений и прерываний.
Как правило, прерывания обрабатываются незаметно для прерванного
процесса. Перед передачей управления обработчику исключения/прерывания
процессор сохраняет в его стеке rIP прерванной инструкции (адрес возврата).
Обработчик прерывания/исключения должен сохранить контекст прерванного процесса,
для возможности его последующего продолжения после завершения обработчика.

При возникновении прерывания или исключения процессор использует номер
прерывания как индекс в IDT. IDT используется во всех режимах работы процессора.

Прерывания можно резделить на 3 категории~\cite{amd_pm_v2}: исключения (англ. Exceptions),
программные прерывания (англ. Software Interrupts) и внешние прерывания (англ. External Interrupts).

Исключения возникают в результате ошибок во время исполнения ПО или внутренних
ошибок процессора. Исключения также могут возникать без наличия ошибочных
ситуаций, например при пошаговом выполнении программы. Исключения считаются
синхронными событиями, т.к. они возникают в результате исполнения прерванной
инструкции.

Программные прерывания возникают в результате вызова прерывания (INT). В
отличие от исключений и внешних прерываний, программные прерывания позволяют
намеренно вызывать обработчики прерываний. Как и исключения, программные
прерывания являются синхронными событиями.

Внешние прерывания генерируются системой в результате возникновения ошибки
или какого-либо события вне процессора. Они доставляются на шину процессора
используя внешние сигналы. Внешние прерывания являются асинхронными событиями,
т.к. они возникают независимо от прерванной инструкции.

При обработке некоторых исключений процессор использует коды ошибок. Код
ошибки помещается в стек перед вызовом обработчика исключения. Код ошибки
может быть в двух форматах: в формате селектора и в формате
страничного исключения~\cite{amd_pm_v2}.


\subsection{Основные характеристики}
Исключения и прерывания имеют несколько различных характеристик, которые
зависят от того как они были доставлены и определяют как следует продолжить выполнение
прерванного процесса.

\subsubsection*{Типы исключений}
Исключения можно разделить на 3 типа:
\begin{enumerate}[1.]
\item Ошибки (англ. Faults) -- возникают на границе перед
инструкцией, вызвавшей исключение. Все изменения, вызванные данной инструкцией
отменются, поэтому инструкция может быть выполнена повторно. Например,
страничное исключение (\#PF).
\item Ловушки (англ. Traps) -- возникают на границе после
инструкции вызвавшей исключение. Процессор полностью выполнил инструкцию,
вызвавшую исключение, т.е. все изменения, вызванные инструкцией сохранены.
rIP указывает на инструкцию, следующую за той, которая вызвала исключение.
Например, точка останова (\#BP).
\item Аварии (англ. Aborts) -- возникают на неопределнной границе,
поэтому обычно они не позволяют продолжить корректное выполнение процесса.
Например, двойная ошибка (\#DF).
\end{enumerate}

\subsubsection*{Маскирование внешних прерываний}
Программное обеспечение может маскировать некоторые прерывания и исключения.
Маскирование может задержать или не допустить запуск механизма обработки
прерываний при возникновении прерывания. Внешние прерывания можно разделить на
маскируемые и немаскируемые.

Маскируемые прерывания приводят к вызову обработчика прерывания только если
rFLAGS.IF=1. В противном случае они не доставляются до тех пор, пока rFLAGS.IF
не станет равным 0.

Немаскируемые прерывания (NMI) обрабатываются независимо от значения rFLAGS.IF.
Однако при возникновении NMI прерывания, последующие NMI прерывания будут
замаскированы до выполнения инструкции IRET.

\subsection{Векторы прерываний}
Определенным исключениям и прерываниям назначены фиксированные номера (также
называемые векторами прерываний). Вектор прерывания используется механизмом обработки
прерываний для определения точки входа в обработчик прерывания. Можно использовать до
256 векторов прерываний. Первые 32 вектора зарезервированы для преопределенных прерываний
и исключительных ситуаций. Для программных прерываний можно использовать любые из
свободных векторов.

Далее приведено кратное описание некоторых векторов прерываний.
Подробное описание всех существующих прерываний можно найти в~\cite{amd_pm_v2}.

\paragraph{\#DE Деление на 0 (Вектор 0).}
Возникает когда делитель в инструкциях DIV и IDIV равен 0. Так же возникает,
если результат не помещается в регистры назначения.

Не возвращает код ошибки. Сохраненный rIP указывает на инструкцию, вызвавшую
исключение.

\paragraph{\#BP Точка останова (Вектор 3).}
Возникает при выполнении инструкции INT3. Не возвращает код ошибки.

\paragraph{\#DF Двойная ошибка (Вектор 8).}
Может возникнуть, когда второе исключение возникло, во время обработки
первого. Возвращает 0 в качесте кода ошибки.

\paragraph{\#GP Нарушение защиты (Вектор 13).}
Возникает при нарушении защиты или неверном использовании функций AMD64.
Возвращает код ошибки в формате селектора.

\paragraph{\#PF Страничная ошибка (Вектор 14).}
Может возникнуть при доступе к памяти, в одной из следующих ситуаций:
\begin{enumerate}[1.]
\item Элемент таблицы страничного преобразования, задействованный в
преобразовании адреса, отсутствует в физической памяти.
\item Попытка процессора выполнить инструкцию из неисполняемой страницы.
\item При доступе к памяти была нарушена одна из проверок
(пользователь/супервизор, чтение/запись, или обе).
\item Зарезервированный бит в одном из элементов таблицы страничного
преобразования установлен в 1.
\end{enumerate}

Процессор сохраняет виртуальный адрес, вызвавший страничное
исключение в регистре CR2. Формат кода ошибки показан на
рис.~\ref{fig:page_fault_error_code}.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/page-fault-error-code}
  \caption{Код ошибки при страничном исключении}
  \label{fig:page_fault_error_code}
\end{figure}

Код ошибки в содержит следующую информацию:
\begin{enumerate}[1.]
\item Бит <<P>> -- бит 0. Если этот бит сброшен в 0, значит страничное исключение было
вызвано отсутствием страницы. Иначе -- оно было вызвано нарушением одной из
страничных проверок.
\item Бит <<R/W>> -- бит 1. Если этот бит сброшен в 0 -- исключение было сгенерировано
при операции чтения. Иначе -- исключение было сгенерировано при операции записи.
\item Бит <<U/S>> -- бит 2. Если этот бит сброшен в 0 -- ошибка была вызвана при
доступе в режиме супервизора (CPL=0, 1, 2). В противном случае -- ошибка была
вызвана в режиме пользователя (CPL=3).
\item Бит <<RSV>> -- бит 3. Если этот бит установлен в 1 -- ошибка была вызвана в
результате чтения процессором единицы (1) из зарезервированного поля в
элементе таблицы страничного преобразования.
\item Бит <<I/D>> -- бит 3. Если этот бит установлен в 1 -- ошибка была сгенерирована
при попытке извлечения инструкции. В противном случае этот бит
сброшен в 0. Этот бит определен только если включена функция запрета
исполнения (EFER.NXE=1 и CR4.PAE=1).
\end{enumerate}


\paragraph{Прерывания определенные пользователем (Вектора 32-255).}
Возникают в следующих случаях:
\begin{enumerate}[1.]
\item Процессору поступает сигнал о наличии внешнего прерывания.
\item Программное обеспечение выполняет инструкцию INTn, в которой n
определяет номер прерывания.
\end{enumerate}

Не возвращают код ошибки. Значение rIP зависит от источника прерывания:
\begin{enumerate}[1.]
\item Обработчики внешних прерываний вызываются на границах инструкций. Сохраненный rIP
	указывает на прерванную инструкцию (не выполненную).
\item Если прерывание возникло в результате выполнения инструкции INTn,
сохраненный rIP указывает на инструкцию, следующую за INTn.
\end{enumerate}

Внешние прерывания можно замаскировать, установив rFLAGS.IF=0. Программные
прерывания нельзя отключить.

\subsection{Обработа прерываний в длинном режиме}
\subsubsection*{Шлюзы прерываний и шлюзы ловушек}
В длинном режиме передача управления обработчику прерывания/исключения
осуществляется через дескрипторы шлюзов. В данном режиме IDT состоит из 256
16-байтных дескрипторов. Дескрипторы шлюзов делятся на 2 типа: дескрипторы шлюзов
прерываний (англ. Interrupt Gates) и дескрипторы шлюзы ловушек (англ. Trap Gates).

Отличие между ними в том, что при переходе через шлюз прерывания процессор
автоматически запрещает прерывания (сбрасывает RFLAGS.IF в 0).

\subsubsection*{Обработчики прерываний}
При возникновении прерывания процессор умножает номер прерывания на 16 и
использует результат в качестве смещения в IDT. Найденный дескриптор шлюза
содержит селектор сегмента и 64-битное смещение (виртуальный адрес обработчика
прерывания). Селектор сегмента указывает на дескриптор сегмента кода
расположенный в GDT или LDT. Дескриптор сегмента кода используется только для
проверки доступа и перевода процессора в длинный режим.

На рис.~\ref{fig:locating_interrupt_handler} показано как происходит поиск
обработчика прерывания в длинном режиме.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/locating-interrupt-handler}
  \caption{Определение положения обработчика прерывания в длинном режиме}
  \label{fig:locating_interrupt_handler}
\end{figure}


\subsubsection*{Стек обработчика прерывания}
В длинном режиме указатель стека прерванной программы (SS:RSP) всегда заносится в
стек обработчика прерывания, независимо от того был ли изменен уровень
привелегий. Регистр SS не используется в 64-битном режиме, SS заносится для
обеспечения возможности возврата из обработчика прерывания в режиме
совместимости.

В длинном режиме при вызове обработчика прерывания процессор выполняет
следующие действия~\cite{amd_pm_v2}:
\begin{enumerate}[1.]
\item Выравнивает стек обработчика прерывания (выполняет побитовое <<И>> RSP с маской 0xFFFF\,FFFF\,FFFF\,FFF0)
\item Если поле IST в дескрипторе шлюза прерывания не равно 0, оно используется в качестве индекса в массиве
	IST TSS. Полученное из TSS значения заносится в RSP.
\item Если необходимо изменить уровень привилегий, уровень привелегий требуемого
	дескриптора (DPL) используется в качестве индекса в TSS для выбора
	нового указателя стека (если не используется IST), в регистр SS заносится 0.
\item Заносит в новый стек предыдущие значения SS:RSP. Значение SS дополняется
	6 байтами, чтобы быть выровненным по 8-байтной границе.
\item Заносит 64-битное значение RFLAGS в новый стек. Старшие 32 бита имеют
	значение 0.
\item Сбрасывает флаги TF, NT, RF в регистре флагов RFLAGS в 0.
\item Если дескриптор шлюза описывает шлюз прерывания -- процессор
	сбрасывает RFLAGS.IF в 0.
\item Заносит в стек CS:RIP прерванной программы. Значение CS дополняется 6
	байтами, чтобы быть выровненным по 8-байтной границе.
\item Если данное прерывание возвращает код ошибки -- процессор заносит этот
	код в стек. Код ошибки дополняется 4 байтами, чтобы быть выровненным
	по 8-байтной границе.
\item Загружает селектор сегмента из дескриптора шлюза в регистр CS. Процессор
	проверяет что целевой сегмент кода является 64-битным сегментом кода.
\item Загружает смещение из дескриптора шлюза в RIP.
\end{enumerate}

На рис.~\ref{fig:interrupt_handler_stack} показано состояние стека после
передачи управления обработчику прерывания.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/interrupt-handler-stack}
  \caption{Стек обработчика прерывания}
  \label{fig:interrupt_handler_stack}
\end{figure}

В длинном режиме при переключении стека из-за смены уровня привилегий,
новое значение для SS выбирается не из TSS (как в защищенном режиме). В
длинном режиме из TSS берется только значение RSP, а в SS заносится ноль,
позволяя тем самым обрабатывать вложенные прерывания. В SS.RPL заносится
значение текущего уровня привилегий (CPL).

Стек обработчика прерывания при смене уровня привилегий, выглядит так же, как
стек обработчика прерывания без смены уровня привилегий, меняется только
регистр SS (в него заносится 0).

\subsubsection*{Таблица стеков обработчиков прерываний}
В длинном режиме введен новый механизм переключения стеков -- IST, который
можно использовать в качестве альтернативы описанному выше механизму.

При использование данного механизма указатель стека переключается всегда. Данный механизм
можно использовать отдельно для разных векторов прерываний, испльзуя поле IST
в дескрипторах шлюзов (в IDT).

На рис.~\ref{fig:interrupt_handler_stack_ist} показано как используется данный
механизм. Если при возникновении прерывания поле IST не равно 0, процессор
использует значение IST в качестве индекса в TSS, загружая таким образом указатель стека
(RSP) для обработчика прерывания. Если изменяется текущий уровень привилегий
-- в регистр SS загружается 0 и в SS.RPL заносится значение нового уровня
привилегий. После того как стек загружен, процессор сохраняет в него предыдущий
указатель стека, флаги процессора (RFLAGS), адрес возврата и код ошибки (если
необходим). После этого управление передается обработчику прерывания. Если два
обработчика прерывания используют один и тот же стек и второе прерывание
возникнет во время обработки первого -- оно затрет стек обработчика первого прерывания.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/interrupt-handler-stack-ist}
  \caption{Переключение стека с использованием IST}
  \label{fig:interrupt_handler_stack_ist}
\end{figure}

\subsubsection*{Возврат из обработчика прерывания}
Для возврата в прерванную программу используется команда IRET. Механизм
обработки прерываний всегда использует 64-битный стек при сохранении значений
для обработчика прерываний, обработчик прерываний всегда выполняется в
64-битном режиме.

Если при вызове обработчика прерывания в длинном режиме происходит изменение
уровня привилегий -- в SS будет загружен нулевой селектор. Если обработчик
прерывания будет прерван -- нулевой селектор будет сохранен в стеке, а в SS
будет повторно загружен другой нулевой селектор. Использование нулевого
селектора таким способом позволяет процессору правильно обрабатывать вложенные
вызовы обработчиков прерываний.

В длинном режиме, нулевой селектор в SS говорит о наличии вложенных обработчиков прерываний, поэтому
в длинном режиме инструкция IRET при определенных условиях (обработчик находится на 0, 1 или 2 уровне
привилегий в 64-битном режиме) может выталкивать из стека нулевой селектор в SS и не вызывать исключение \#GP.



\section{PIC, APIC и IO APIC}
\label{sec:apic_ioapic}
Программируемый контроллер прерываний 8259 (PIC) использовался для доставки процессору прерываний
от внешних устройств, что позволяло избежать трат поцессорного времени на опрос устройств.
В настоящее время считается устаревшим, современные архитектуры вместо него используют APIC и IOAPIC.

APIC осуществляет поддержку прерываний в архитектуре AMD64. Локальный APIC принимает прерывания и
доставляет их процессору. На рис.~\ref{fig:apic-schema} показана схема реализации APIC.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=0.9\textwidth]{inc/dia/apic-schema}
  \caption{Схема реализации APIC}
  \label{fig:apic-schema}
\end{figure}

\subsection{Источники прерываний локального APIC}
С каждым ядром ЦП связан локальный APIC, который принимает прерывания от следующих источников:
\begin{itemize}
	\item Внешние прерывания от IOAPIC (включая LINT0 и LINT1)
	\item Унаследованные прерывания (INTR и NMI) от PIC
	\item Межпроцессорные прерывания (IPI) от других локальных APIC. Используются
		для отправки прерываний различным ядрам ЦП.
	\item Локальные прерывания. Локальный APIC получает прерывания от таймера,
		счетчиков производительности, термальных сенсоров, а также при возникновении
		ошибок APIC.
\end{itemize}

\subsection{Локальный APIC}
Локальный APIC контролируется битом <<AE>> регистра базового адреса APIC (APIC Base Address Register).
Это моделезависимый регистр, который имеет номер 0x0000\,001B (для доступа к регистру необходимо
использовать команды RDMSR и WRMSR, с номером нужного регистра в регистре ECX).
На рис.~\ref{fig:apic-base-address-register} показан формат регистра базового адреса APIC.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/apic-base-address-register}
  \caption{Формат регистра базового адреса APIC}
  \label{fig:apic-base-address-register}
\end{figure}

Регистр базового адреса APIC включает следующие поля:
\begin{itemize}
\item Бит <<BSC>>. Бит 8. Показывает является ли текущее ядро загрузочным ядром загрузочного процессора.
\item Бит <<AE>>. Бит 11. Данный бит активирует APIC.
\item Базовый адрес APIC. Биты 51:12. Задает базовый физический адрес регистров APIC (по умолчанию
	равен 0xFEE0\,0000).
\end{itemize}

\subsection{Регистры APIC}
Настройка APIC производится с использованием отображенных в память регистров APIC.
Адреса регистров вычисляются путем сложения базового адреса APIC и смещения регистра.
Базовый адрес APIC можно задавать через моделезависимый регистр базового адреса APIC.

Регистры APIC выровнены по 16-байтной границе. Доступ к ним должен осуществляться
по адресам, выровненным по 4-байтной границе.

Подробное описание и назначение регистров APIC можно найти в ~\cite{amd_pm_v2}.

Каждое ядро процессора в системе имеет уникальный идентификатор локального APIC (APIC ID).
Его значение определяется аппаратным обеспечением в зависимости от идентификатора процессора
и количества ядер. Как показано на рис.~\ref{fig:local-apic-id}, идентификатор локального APIC
находится в регистре APIC ID, в битах 31:24.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/local-apic-id}
  \caption{Формат регистра APIC ID (смещение 20h)}
  \label{fig:local-apic-id}
\end{figure}

\subsection{Таймер APIC}
Таймер APIC это программируемый 32-битный счетчик, используемый ПО, для генерации событий.
Таймер может работать в двух режимах -- разовый и периодичный, в зависимости от значения бита <<TM>> (17)
в регистре LVT (показан на рис.~\ref{fig:apic-timer-lvt-register}). Когда значение счетчика таймера
достигает нуля -- генерируется прерывание (если бит <<M>> в регистре LVT сброшен). В случае использования
таймера в периодичном режиме, после генерации прерывания, счетчик таймера повторно инициализируется
значением из регистра, содержащего начальное значение счетчика и отсчет начинается сначала.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/apic-timer-lvt-register}
  \caption{Формат регистра APIC Timer LVT (смещение 320h)}
  \label{fig:apic-timer-lvt-register}
\end{figure}

Для управления таймером определены 3 регистра: CCR (англ. Current Count Register),
ICR (англ. Initial Count Register) и DCR (англ. Divide Configuration Register).

Регистр ICR имеет размер 32 бита и задает начальное значение счетчика таймера.

Регистр CCR имеет размер 32 бита, инициализируется значением регистра ICR и
уменьшается на каждый тик таймера на значение, зависящее от регистра DCR. Когда значение
данного регистра достигает нуля, генерируется прерывание.

Регистр DCR (рис.~\ref{fig:apic-timer-dcr-register}) имеет размер 32 бита и задает значение, которое вычитается из ICR
на каждом тике таймера. Значение определяется в соответствии с таблицей~\ref{tab:apic_timer_dcr_values}.
\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/apic-timer-dcr-register}
  \caption{Формат регистра APIC Timer DCR (смещение 3E0h)}
  \label{fig:apic-timer-dcr-register}
\end{figure}

\begin{table}[ht!]
  \centering
  \caption{Значения делителя, в зависимости от значения DCR}
  \label{tab:apic_timer_dcr_values}
  \begin{tabular}{|c|c|}
    \hline
    Биты 3, 1:0 регистра DCR & Значение делителя \\
    \hline
    000 & 2 \\
    \hline
    001 & 4 \\
    \hline
    010 & 8 \\
    \hline
    011 & 16 \\
    \hline
    100 & 32 \\
    \hline
    101 & 64 \\
    \hline
    110 & 128 \\
    \hline
    111 & 1 \\
    \hline
  \end{tabular}
\end{table}

\subsection{IOAPIC}
IOAPIC (I/O Advanced Programmable Interrupt Controller) используется для
управления внешними прерываниями. Каждый IOAPIC может обрабатывать до 24х типов прерываний.

Настройка IOAPIC производится с использованием трех отображенных на память регистров:
IOAPICBASE, IOREGSEL и IOWIN. Для доступа к внутренним регистрам IOAPIC используется косвенная
адресация через регистры IOREGSEL и IOWIN, расположение которых определяется значением
регистра IOAPICBASE. Доступ ко всем регистрам осуществляется с использованием 32-битных
операций чтения и записи, т.е. для модификация одного поля (бит, байт и т.д.) необходимо
прочитать 32 бита, изменить нужное поле и записать обратно.

Подробное описание всех регистров IOAPIC приведено в~\cite{ioapic}.

\subsubsection*{Отображенные на память регистры IOAPIC}
\paragraph{IOREGSEL.} Регистр IOREGSEL используется для выбора внутреннего регистра IOAPIC для чтения/записи.
После выбора требуемого регистра, данные можно прочитать/записать используя регистр IOWIN. Формат регистра
IOREGSEL показан на рис.~\ref{fig:ioapic-ioregsel}. По умолчанию данный регистр расположен по адресу 0xFEC0\,0000.
\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/ioapic-ioregsel}
  \caption{Формат регистра IOREGSEL}
  \label{fig:ioapic-ioregsel}
\end{figure}

\paragraph{IOWIN.} Данный регистр имеет размер 32 бита и используется для чтения/записи во
внутренний регистр IOAPIC, который был выбран с использованием регистра IOREGSEL.
По умолчанию данный регистр расположен по адресу 0xFEC0\,0010.

\subsubsection*{Внутренние регистры IOAPIC}
\paragraph{IOAPICID.} Как показано на рис.~\ref{fig:ioapic-id}, данный регистр содержит идентификатор IOAPIC (биты 27:24),
который используется в качестве физического имени IOAPIC. В данный регистр необходимо записать корректный идентификатор
IOAPIC перед использование других регистров IOAPIC. Данный регистр имеет номер 0 (для доступа через IOREGSEL).
\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/ioapic-id}
  \caption{Формат регистра IOAPICID}
  \label{fig:ioapic-id}
\end{figure}

\paragraph{IOREDTBL[23:0].} Включает 24 64-битных элемента, для 24-х различных сигналов. В отличие от PIC -- приоритеты
прерываний не зависят от физического номера сигнала (они определяются номером обработчика прерывания). Для каждого
сигнала ОС может задать полятность (высокая или низкая), режим возникновения прерывания (по фронту или по спаду) и некоторые
другие свойства. Информация из регистра IOREDTBL используется для преобразования номера физического сигнала в сообщение для
APIC. На рис.~\ref{fig:ioapic-ioredtbl} показан формат элемента IOREDTBL. Так как элементы имеют размер 64-бита, каждый
из них описываеся двумя регистрами APIC, например для доступа к первому элементу используются регистры с номерами 10h и 11h,
ко второму -- 12h и 13h и т.д.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/ioapic-ioredtbl}
  \caption{Формат регистров IOREDTBL[23:0]}
  \label{fig:ioapic-ioredtbl}
\end{figure}

Каждый элемент IOREDTBL включает следующие поля:
\begin{itemize}
\item ID получателя. Биты 63:56. Определяет получателя прерывания.
\item Бит <<IM>> (16). Если установлен в 1 -- прерывания замаскированы.
\item Бит <<TM>> (15). Определяет режим срабатывания прерываний.
\item Бит <<IRR>> (14). Устанавливается при получении прерывания.
\item Бит <<POL>> (13). Определяет полярность сигнала прерывания.
\item Бит <<DS>> (12). Содержит текущий статус доставки прерывания.
\item Бит <<DM>> (11). Определяет как обрабатывать поле <<ID получателя>>.
\item Режим доставки. Биты 10:8. Сущесвтует несколько режимов доставки, в данной работе используется
	фиксированный режим (значение 0) -- доставляет указанное прерывание всем ядрам процессоров,
	перечисленным в поле <<ID получателя>>. Подробное описание всех режимов приведено в~\cite{ioapic}.
\item Номер вектора. Биты 7:0. Содержит номер вектора прерывания, который необходимо вызвать.
	Допустимые значения лежат в диапазоне от 0x10 до 0xFE.
\end{itemize}


\section{Инициализация процессора и переход в длинный режим}
\label{sec:long_mode_activation}

\subsection{Начальная загрузка компьютера}
Загрузка системы начинается с того, что после включения компьютера
управление передается на реальный адрес 0xFFFF\,FFF0~\cite{amd_pm_v2}, где находится
ПЗУ с кодом BIOS~\cite{mstu_os_dev_method}.

После того, как BIOS проинициализирует устройства, вектора прерываний реального
режима и выберет загрузочный дисковод или жесткий диск, он загружает его
первый сектор (512~байт) по адресу 0x7c00, после чего передает управление на
него (реальный адрес 0000:7c00). Два последних байта сектора должны иметь
значения 0x55 и 0xAA, иначе BIOS не сочтет сектор загрузочным. Таким образом,
размер начальной части загрузчика ОС фактически не может превышать 510~байт.

\subsection{Инициализация защищенного режима}
Перед активацией длинного режима необходимо перейти в защищенный режим.
Для этого необходимо загрузить GDT, содержащую дескриптор сегмента кода и
дескриптор сегмента данных, доступный для чтения/записи.

После того, как новая GDT загружена, переход в защищенный режим можно выполнить установив CR0.PE в 1.

\subsection{Инициализация длинного режима}
В защищенном режиме системное ПО может подготовить структуры данных, необходимые для перехода в
длинный режим и сохранить их в произвольном месте в пределах первых 4х гигабайт физической памяти.
Эти структуры данных можно будет переместить за пределы 4х гигабайт после перехода в длинный режим.
Для перехода в длинный режим необходимы следующие структуры данных:
\begin{itemize}
\item 4 уровня таблиц страниц. Для перехода в длинный режим, также необходимо активировать PAE.
\item GDT, содержащая дескрипторы сегментов для ПО работающего в 64-битном режиме и в
	режиме совместимости, включающая:
	\begin{enumerate}[1.]
	\item Дескриптор сегмента кода для длинного режима (должен быть установлен бит <<L>>).
	\item Дескриптор сегмента данных для ПО, работающего в режиме совместимости.
	\end{enumerate}

	Существующая GDT защищенного режима может быть использована для хранения перечисленных
	выше дескрипторов.
\end{itemize}

\subsection{Активация и переход в длинный режим}
Для активации длинного режима необходимо установить бит EFER.LME в 1. Однако переход в длинный режим
не будет выполнен до активациии страничного преобразования. После того, как системное ПО
активирует страничное преобразование, при активированном длинном режиме, процессор перейдет в
длинный режим, установив при этом бит EFER.LMA в 1.

Для выбора подрежима работы процессора в длинном режиме используются 2 бита дескриптора сегмента кода (CS.L и CS.D).
Комбинация CS.L=1, CS.D=0 -- переводит процессор в 64-битный режим. Комбинация CS.L=0, CS.D=0 -- в
режим совместимости.

\subsubsection*{Переход в длинный режим}
Для перехода в защищенный режим, системное ПО должно выполнить следующие действия:
\begin{enumerate}[1.]
\item В любой последовательности:
	\begin{itemize}
	\item Активировать механизм расширения физических адресов, установив бит CR4.PAE в 1. Это
		необходимо сделать до активации страничного преобразования.
	\item Загрузить в регистр CR3 физический адрес PML4.
	\item Активировать длинный режим, установив бит EFER.LME в 1.
	\end{itemize}
\item Активировать страничное преобразование, установив бит CR0.PG в 1. В результате процессор установит бит EFER.LMA в 1.
\end{enumerate}

\subsubsection*{Обновление ссылок на таблицы системных дескрипторов}
После перехода в длинный режим регистр GDTR ссылается на GDT унаследованного режима, которая расположена
в пределах первых 4-x гигабайт виртуального адресного пространства. Системемному ПО необходимо обновить GDTR,
чтобы он указывал на 64-битную GDT, используя команду LGDT.


\section{Типы архитектур ядер ОС}
\subsection{Монолитное ядро}
Монолитное ядро -- ядро, которое включает в себя весь набор средств для
взаимодействия прикладных программ друг с другом и с аппаратным обеспечением.
На рис.~\ref{fig:os-kernel-monolit} показана схема ОС с монолитным ядром.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/os-kernel-monolit}
  \caption{ОС с монолитным ядром}
  \label{fig:os-kernel-monolit}
\end{figure}

Принципиальной особенностью монолитного ядра является то, что все компоненты
ядра находятся в одном адресном пространстве, используют общие структуры
данных и взаимодействуют друг с другом используя вызовы процедур.

Так как все компоненты ядра выполняются в одном адресном пространстве,
отсутствуют накладные расходы при взаимодействии компонентов между собой (т.к.
отсутствуют лишние переключения контекста).

С другой стороны, ошибка в одном из компонентов может привести к
неработоспособности всего ядра. Ещё одним недостатком является то,
что при изменении одного из компонентов ядра, необходимо
пересобирать все ядро.

Примеры ОС с монолитным ядром: UNIX, Linux, KolibriOS.

\subsection{Микроядро}
При использовании микроядерной архитектуры, ядро содержит только фукнции для
взаимодействия (IPC) и набор абстракций для работы с аппаратным обеспечением.
Основная часть функций ядра реализуется с использованием пользовательский
процессов, называемых сервисами. Взаимодействие между компонентами ядра
осуществляется путем передачи сообщений. На рис.~\ref{fig:os-kernel-micro} показана
схема ОС с микроядром.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/os-kernel-micro}
  \caption{ОС с микроядром}
  \label{fig:os-kernel-micro}
\end{figure}

К преимуществам данного подхода относят~\cite{os_dev}: повышение
отказоустойчивости ядра (система может продолжить работать даже после
отказа одного из сервисов, т.к. каждый сервис имеет отдельное адресное
пространство), уменьшение объема кода, который должен быть реентерабельным
(может быть полезным при переносе ОС на многопроцессорную систему).

Основным недостатком данной архитектуры является снижение производительности
(по сравнению с монолитной архитектурой), связанное с передачей сообщений и
увеличением числа переключений контекста (для взаимодействия между сервисами).

Примеры ОС с микроядром: Symbian OS, Mach, Minix, Minix.

\subsection{Экзоядро}
Данная архитектура предполагает, что ядро операционной системы предоставляет
функции только для взаимодействия между процессами и безопасного выделения и
освобождения ресурсов. Прикладные программы взаимодействуют с аппаратным
обеспечением используя сторонние по отношению к ядру библиотеки.
На рис.~\ref{fig:os-kernel-exo} показана схема ОС с экзоядром.

\begin{figure}[ht!]
  \centering
  \includegraphics[width=1.0\textwidth]{inc/dia/os-kernel-exo}
  \caption{ОС с экзоядром}
  \label{fig:os-kernel-exo}
\end{figure}

Основным достоинством данного подхода является то, что прикладное ПО получает
практически прямой доступ к ресурсам системы, что позволяет повысить производительность
за счет удаления ненужных конкретной задаче абстракций.

Примером ОС с таким ядром является JOS.

\section{Существующие учебные операционные системы}
\paragraph{PhantomEx.} -- 32-разрядная многозадачная ОС, предназначенная для изучения
принципов организации ОС для архитектуры x86~\cite{phantomex}. Разработал Дмитрий Притыкин,
преподаватель РГУПС. Версия 0.0.1 была представлена в октябре 2013 года.

Написана с целью раскрытия следующих вопросов~\cite{os_dev}:
\begin{enumerate}[1.]
\item Инструменты, используемые при разработке ОС.
\item Работа процессора в защищенном режиме (механизмы сегментного преобразования
	и обработки прерываний).
\item Управления памятью в ОС.
\item Многозадачность.
\item Взаимодейтсвие прикладного ПО и ядра.
\end{enumerate}

Достоинства:
\begin{enumerate}[1.]
\item Наличие виртуальной файловой системы.
\item Поддержка механизма страничного преобразования.
\item Поддержка многозадачности.
\item Поддержка механизма системных вызовов.
\item Возможность управления динамическим выделением памяти на прикладном уровне.
\item Поддержка межпроцессного взаимодействия.
\item Работа с виртуальными консолями.
\end{enumerate}

Недостатки:
\begin{enumerate}[1.]
\item Отсутствие поддержки работы с несколькими процессорами.
\item Реализована под устаревшую архитектуру x86.
\end{enumerate}


\paragraph{xv6.} Операционная система из курса MIT~\cite{mit_xv6}. Используется в теоретическом
курсе для изучения основ функционирования операционных систем.

Достоинства:
\begin{enumerate}[1.]
\item Поддержка механизма страничного преобразования.
\item Поддержка многозадачности.
\item Поддержка механизма системных вызовов.
\item Поддержка межпроцессного взаимодействия.
\item Поддержка работы с несколькими процессорами, использование механизмов синхронизации.
\item Поддержка файловой системы.
\item Наличие драйвера сетевой карты.
\end{enumerate}

Недостатки:
\begin{enumerate}[1.]
\item Реализована под устаревшую архитектуру x86.
\end{enumerate}


\paragraph{JOS.} Операционная система из курса MIT~\cite{mit_os_dev}. Используется для
выполнения лабораторных работ.

Достоинства:
\begin{enumerate}[1.]
\item Поддержка механизма страничного преобразования.
\item Поддержка многозадачности.
\item Поддержка механизма системных вызовов.
\item Поддержка межпроцессного взаимодействия.
\end{enumerate}

Недостатки:
\begin{enumerate}[1.]
\item Отсутствие файловой системы.
\item Отсутствие многопроцессорной обработки.
\item Реализована под устаревшую архитектуру x86.
\end{enumerate}


\section{Выводы}
Разработка новой учебной ОС является актуальной задачей, т.к. на данный момент не существует учебных ОС,
поддерживающих 64-битный режим (AMD64, Intel64).
